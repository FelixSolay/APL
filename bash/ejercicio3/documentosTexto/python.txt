Traducido y empaquetado por
 la comunidad de Python Argentina
 Py  Ar
 http://www.python.org.ar
Autor original: Guido van Rossum 
Editor original: Fred L. Drake, Jr.
 Este material fue traducido por voluntarios del
 grupo de usuarios de Python de Argentina.
 Una versión actualizada de este Tutorial
 puede encontrarse en:
 http://tutorial.python.org.ar/
 Octubre 2017
 Este PDF fue generado usando la herramienta rst2pdf
 Copyright © Python Software Foundation
 Esta documentación está cubierta por la Licencia PSF para Python 3.6.0, que 
basicamente permite que use, copies, modifiques y distribuyas este contenido. 
Para un mayor detalle: http://docs.python.org/3/license.html
3
Contenido
 Introducción 1
 Abriendo tu apetito 3
 Usando el intérprete de Python 5
 Invocando al intérprete 5
 Pasaje de argumentos 6
 Modo interactivo 6
 El intérprete y su entorno 6
 Codificación del código fuente 6
 Una introducción informal a Python 8
 Usar Python como una calculadora 8
 Números 8
 Cadenas de caracteres 9
 Listas 13
 Primeros pasos hacia la programación 14
 Más herramientas para control de flujo 16
 La sentencia if 16
 La sentencia for 16
 La función range() 17
 Las sentencias break, continue, y else en lazos 18
 La sentencia pass 18
 Definiendo funciones 19
 Más sobre definición de funciones 20
 Argumentos con valores por omisión 20
 Palabras claves como argumentos 22
 Listas de argumentos arbitrarios 23
 Desempaquetando una lista de argumentos 23
 Expresiones lambda 24
 Cadenas de texto de documentación 24
 Anotación de funciones 24
 Intermezzo: Estilo de codificación 25
 Estructuras de datos 26
 Más sobre listas 26
 Usando listas como pilas 27
 Usando listas como colas 27
 Comprensión de listas 28
 Listas por comprensión anidadas 29
 La instrucción del 30
 Tuplas y secuencias 30
 Conjuntos 31
 Diccionarios 32
 i
Técnicas de iteración 33
 Más acerca de condiciones 34
 Comparando secuencias y otros tipos 35
 Módulos 36
 Más sobre los módulos 37
 Ejecutando módulos como scripts 37
 El camino de búsqueda de los módulos 38
 Archivos "compilados" de Python 38
 Módulos estándar 39
 La función dir() 39
 Paquetes 41
 Importando * desde un paquete 42
 Referencias internas en paquetes 43
 Paquetes en múltiples directorios 43
 Entrada y salida 46
 Formateo elegante de la salida 46
 Viejo formateo de cadenas 49
 Leyendo y escribiendo archivos 49
 Métodos de los objetos Archivo 50
 Guardar datos estructurados con json 51
 Errores y excepciones 53
 Errores de sintaxis 53
 Excepciones 53
 Manejando excepciones 54
 Levantando excepciones 56
 Excepciones definidas por el usuario 56
 Definiendo acciones de limpieza 57
 Acciones predefinidas de limpieza 58
 Clases 59
 Unas palabras sobre nombres y objetos 59
 Ámbitos y espacios de nombres en Python 59
 Ejémplo de ámbitos y espacios de nombre 61
 Un primer vistazo a las clases 61
 Sintaxis de definición de clases 61
 Objetos clase 62
 Objetos instancia 63
 Objetos método 63
 Variables de clase y de instancia 64
 Algunas observaciones 65
 Herencia 66
 Herencia múltiple 67
 Variables privadas 67
 ii
Cambalache 68
 Iteradores 69
 Generadores 70
 Expresiones generadoras 70
 Pequeño paseo por la Biblioteca Estándar 72
 Interfaz al sistema operativo 72
 Comodines de archivos 72
 Argumentos de linea de órdenes 72
 Redirección de la salida de error y finalización del programa 73
 Coincidencia en patrones de cadenas 73
 Matemática 73
 Acceso a Internet 74
 Fechas y tiempos 74
 Compresión de datos 75
 Medición de rendimiento 75
 Control de calidad 75
 Las pilas incluidas 76
 Pequeño paseo por la Biblioteca Estándar - Parte II 77
 Formato de salida 77
 Plantillas 78
 Trabajar con registros estructurados conteniendo datos binarios 79
 Multi-hilos 79
 Registrando 80
 Referencias débiles 80
 Herramientas para trabajar con listas 81
 Aritmética de punto flotante decimal 82
 Entornos Virtuales y Paquetes 83
 Introducción 83
 Creando Entornos Virtuales 83
 Manejando paquetes con pip 84
 ¿Y ahora qué? 87
 Edición de entrada interactiva y sustitución de historial 89
 Autocompletado con tab e historial de edición 89
 Alternativas al intérprete interactivo 89
 Aritmética de Punto Flotante: Problemas y Limitaciones 91
 Error de Representación 93
 Links a la documentación de Python 97
 Extendiendo e Integrando el Intérprete de Python 97
 Referencia de la API Python/C 97
 La referencia de la biblioteca 97
 Tipos integrados 97
 Excepciones integradas 97
 iii
La referencia del lenguaje
 97
 Expresiones
 Declaraciones simples
 Declaraciones compuestas
 Instalando módulos de Python
 Glosario
 Distribuyendo módulos de Python
 Línea de comandos y entorno
 Apéndice
 Modo interactivo
 Manejo de errores
 Programas ejecutables de Python
 El archivo de inicio interactivo
 Los módulos de customización
 97
 98
 98
 98
 98
 98
 98
 101
 101
 101
 101
 101
 102
 iv

Introducción
 Python es un lenguaje de programación poderoso y fácil de aprender. Cuenta con estructuras de datos eficientes y de alto
 nivel y un enfoque simple pero efectivo a la programación orientada a objetos. La elegante sintaxis de Python y su tipado
 dinámico, junto con su naturaleza interpretada, hacen de éste un lenguaje ideal para scripting y desarrollo rápido de
 aplicaciones en diversas áreas y sobre la mayoría de las plataformas.
 El intérprete de Python y la extensa biblioteca estándar están a libre disposición en forma binaria y de código fuente para las
 principales plataformas desde el sitio web de Python, https://www.python.org/, y puede distribuirse libremente. El mismo sitio
 contiene también distribuciones y enlaces de muchos módulos libres de Python de terceros, programas y herramientas, y
 documentación adicional.
 El intérprete de Python puede extenderse fácilmente con nuevas funcionalidades y tipos de datos implementados en C o
 C++ (u otros lenguajes accesibles desde C). Python también puede usarse como un lenguaje de extensiones para
 aplicaciones personalizables.
 Este tutorial introduce de manera informal al lector a los conceptos y características básicas del lenguaje y el sistema de
 Python. Es bueno tener un interprete de Python a mano para experimentar, sin embargo todos los ejemplos están aislados,
 por lo tanto el tutorial puede leerse estando desconectado.
 Para una descripción de los objetos y módulos estándar, mirá La referencia de la biblioteca. La referencia de la biblioteca
 provee una definición más formal del lenguaje. Para escribir extensiones en C o C++, leé Extendiendo e Integrando el
 Intérprete de Python y la Referencia de la API Python/C. Hay también numerosos libros que tratan a Python en profundidad.
 Este tutorial no pretende ser exhaustivo ni tratar cada una de las características, o siquiera las características más usadas.
 En cambio, introduce la mayoría de las características más notables de Python, y te dará una buena idea del gusto y estilo
 del lenguaje. Luego de leerlo, serás capaz de leer y escribir módulos y programas en Python, y estarás listo para aprender
 más de los variados módulos de la biblioteca de Python descriptos en La referencia de la biblioteca.
 También vale la pena mirar el glosario.
 1

Abriendo tu apetito
 Si trabajás mucho con computadoras, eventualmente encontrarás que te gustaría automatizar alguna tarea. Por ejemplo,
 podrías desear realizar una búsqueda y reemplazo en un gran número de archivos de texto, o renombrar y reorganizar un
 montón de archivos con fotos de una manera compleja. Tal vez quieras escribir alguna pequeña base de datos
 personalizada, o una aplicación especializada con interfaz gráfica, o un juego simple.
 Si sos un desarrollador de software profesional, tal vez necesites trabajar con varias bibliotecas de C/C++/Java pero
 encuentres que se hace lento el ciclo usual de escribir/compilar/testear/recompilar. Tal vez estás escribiendo una batería de
 pruebas para una de esas bibliotecas y encuentres que escribir el código de testeo se hace una tarea tediosa. O tal vez has
 escrito un programa al que le vendría bien un lenguaje de extensión, y no quieres diseñar/implementar todo un nuevo
 lenguaje para tu aplicación.
 Python es el lenguaje justo para ti.
 Podrías escribir un script (o programa) en el interprete de comandos o un archivo por lotes de Windows para algunas de
 estas tareas, pero los scripts se lucen para mover archivos de un lado a otro y para modificar datos de texto, no para
 aplicaciones con interfaz de usuario o juegos. Podrías escribir un programa en C/C++/Java, pero puede tomar mucho tiempo
 de desarrollo obtener al menos un primer borrador del programa. Python es más fácil de usar, está disponible para sistemas
 operativos Windows, Mac OS X y Unix, y te ayudará a realizar tu tarea más velozmente.
 Python es fácil de usar, pero es un lenguaje de programación de verdad, ofreciendo mucha más estructura y soporte para
 programas grandes de lo que pueden ofrecer los scripts de Unix o archivos por lotes. Por otro lado, Python ofrece mucho
 más chequeo de error que C, y siendo un lenguaje de muy alto nivel, tiene tipos de datos de alto nivel incorporados como
 arreglos de tamaño flexible y diccionarios. Debido a sus tipos de datos más generales Python puede aplicarse a un dominio
 de problemas mayor que Awk o incluso Perl, y aún así muchas cosas siguen siendo al menos igual de fácil en Python que en
 esos lenguajes.
 Python te permite separar tu programa en módulos que pueden reusarse en otros programas en Python. Viene con una gran
 colección de módulos estándar que puedes usar como base de tus programas, o como ejemplos para empezar a aprender a
 programar en Python. Algunos de estos módulos proveen cosas como entrada/salida a archivos, llamadas al sistema,
 sockets, e incluso interfaces a sistemas de interfaz gráfica de usuario como Tk.
 Python es un lenguaje interpretado, lo cual puede ahorrarte mucho tiempo durante el desarrollo ya que no es necesario
 compilar ni enlazar. El intérprete puede usarse interactivamente, lo que facilita experimentar con características del lenguaje,
 escribir programas descartables, o probar funciones cuando se hace desarrollo de programas de abajo hacia arriba. Es
 también una calculadora de escritorio práctica.
 Python permite escribir programas compactos y legibles. Los programas en Python son típicamente más cortos que sus
 programas equivalentes en C, C++ o Java por varios motivos:
 • los tipos de datos de alto nivel permiten expresar operaciones complejas en una sola instrucción
 • la agrupación de instrucciones se hace por sangría en vez de llaves de apertura y cierre
 • no es necesario declarar variables ni argumentos.
 Python es extensible: si ya sabes programar en C es fácil agregar una nueva función o módulo al intérprete, ya sea para
 realizar operaciones críticas a velocidad máxima, o para enlazar programas Python con bibliotecas que tal vez sólo estén
 disponibles en forma binaria (por ejemplo bibliotecas gráficas específicas de un fabricante). Una vez que estés realmente
 entusiasmado, podés enlazar el intérprete Python en una aplicación hecha en C y usarlo como lenguaje de extensión o de
 comando para esa aplicación.
 3
Por cierto, el lenguaje recibe su nombre del programa de televisión de la BBC "Monty Python's Flying Circus" y no tiene
 nada que ver con reptiles. Hacer referencias a sketches de Monty Python en la documentación no sólo esta permitido, ¡sino
 que también está bien visto!
 Ahora que ya estás emocionado con Python, querrás verlo en más detalle. Como la mejor forma de aprender un lenguaje es
 usarlo, el tutorial te invita a que juegues con el intérprete de Python a medida que vas leyendo.
 En el próximo capítulo se explicará la mecánica de uso del intérprete. Esta es información bastante mundana, pero es
 esencial para poder probar los ejemplos que aparecerán más adelante.
 El resto del tutorial introduce varias características del lenguaje y el sistema Python a través de ejemplos, empezando con
 expresiones, instrucciones y tipos de datos simples, pasando por funciones y módulos, y finalmente tocando conceptos
 avanzados como excepciones y clases definidas por el usuario.
 4
Usando el intérprete de Python
 Invocando al intérprete
 Por lo general, el intérprete de Python se instala en /usr/local/bin/python3.6 en las máquinas dónde está disponible; poner
 /usr/local/bin en el camino de búsqueda de tu intérprete de comandos Unix hace posible iniciarlo ingresando la orden:
 python3.6
 ...en la terminal. 1 Ya que la elección del directorio dónde vivirá el intérprete es una opción del proceso de instalación, puede
 estar en otros lugares; consultá a tu Gurú Python local o administrador de sistemas. (Por ejemplo, /usr/local/python es una
 alternativa popular).
 En máquinas con Windows, la instalación de Python por lo general se encuentra en C:\Python36, aunque se puede cambiar
 durante la instalación. Para añadir este directorio al camino, podes ingresar la siguiente orden en el prompt de DOS:
 set path=%path%;C:\python36
 Se puede salir del intérprete con estado de salida cero ingresando el carácter de fin de archivo (Control-D en Unix, Control-Z
 en Windows) en el prompt primario. Si esto no funciona, se puede salir del intérprete ingresando: quit().
 Las características para editar líneas del intérprete incluyen edición interactiva, sustitución usando el historial y completado
 de código en sistemas que soportan readline. Tal vez la forma más rápida de detectar si las características de edición están
 presentes es ingresar Control-P en el primer prompt de Python que aparezca. Si se escucha un beep, las características
 están presentes; ver Apéndice Edición de entrada interactiva y sustitución de historial para una introducción a las teclas. Si
 no pasa nada, o si aparece ^P, estas características no están disponibles; solo vas a poder usar backspace para borrar los
 caracteres de la línea actual.
 La forma de operar del intérprete es parecida a la línea de comandos de Unix: cuando se la llama con la entrada estándar
 conectada a una terminal lee y ejecuta comandos en forma interactiva; cuando es llamada con un nombre de archivo como
 argumento o con un archivo como entrada estándar, lee y ejecuta un script del archivo.
 Una segunda forma de iniciar el intérprete es python -c comando [arg] ..., que ejecuta las sentencias en comando,
 similar a la opción -c de la línea de comandos. Ya que las sentencias de Python suelen tener espacios en blanco u otros
 caracteres que son especiales en la línea de comandos, es normalmente recomendado citar comando entre comillas dobles.
 Algunos módulos de Python son también útiles como scripts. Pueden invocarse usando python -m module [arg] ...,
 que ejecuta el código de module como si se hubiese ingresado su nombre completo en la línea de comandos.
 Cuando se usa un script, a veces es útil correr primero el script y luego entrar al modo interactivo. Esto se puede hacer
 pasándole la opción -i antes del nombre del script.
 Todas las opciones de línea de comandos están se descriptas en Línea de comandos y entorno.
 5
Pasaje de argumentos
 Cuando son conocidos por el intérprete, el nombre del script y los argumentos adicionales son entonces convertidos a una
 lista de cadenas de texto asignada a la variable argv del módulo sys. Podés acceder a esta lista haciendo import sys. El
 largo de esta lista es al menos uno; cuando ningún script o argumentos son pasados, sys.argv[0] es una cadena vacía.
 Cuando se pasa el nombre del script con '-' (lo que significa la entrada estándar), sys.argv[0] vale '-'. Cuando se usa-c command, sys.argv[0] vale '-c'. Cuando se usa -m module, sys.argv[0] toma el valor del nombre completo del
 módulo. Las opciones encontradas luego de -c command o -m module no son consumidas por el procesador de opciones de
 Python pero de todas formas almacenadas en sys.argv para ser manejadas por el comando o módulo.
 Modo interactivo
 Se dice que estamos usando el intérprete en modo interactivo, cuando los comandos son leídos desde una terminal. En este
 modo espera el siguiente comando con el prompt primario, usualmente tres signos mayor-que (>>>); para las líneas de
 continuación espera con el prompt secundario, por defecto tres puntos (...). Antes de mostrar el prompt primario, el
 intérprete muestra un mensaje de bienvenida reportando su número de versión y una nota de copyright:
 $ python3.6
 Python 3.6 (default, Sep 16 2015, 09:25:04)
 [GCC 4.8.2] on linux
 Type "help", "copyright", "credits" or "license" for more information.
 >>>
 Las líneas de continuación son necesarias cuando queremos ingresar un constructor multilínea. Como en el ejemplo, mirá la
 sentencia if:
 >>> el_mundo_es_plano = True
 >>> if el_mundo_es_plano:
 ...     
print("¡Tené cuidado de no caerte!")
 ...
 ¡Tené cuidado de no caerte!
 Para más información sobre el modo interactivo, ve a Modo interactivo.
 El intérprete y su entorno
 Codificación del código fuente
 Por default, los archivos fuente de Python son tratados como codificados en UTF-8. En esa codificación, los caracteres de la
 mayoría de los lenguajes del mundo pueden ser usados simultáneamente en literales, identificadores y comentarios, a pesar
 de que la biblioteca estándar usa solamente caracteres ASCII para los identificadores, una convención que debería seguir
 cualquier código que sea portable. Para mostrar estos caracteres correctamente, tu editor debe reconocer que el archivo
 está en UTF-8 y usar una tipografía que soporte todos los careacteres del archivo.
 Para especificar una codificación distinta de la por defecto, un línea de comentario especial debe ser agregada como la
 primera línea del archivo. La sintaxis es como sigue:
 # -*- coding: encoding -*
Donde encoding es uno de los codecs válidos soportados por Python.
 Por ejemplo, para indicar que el encoding Windows-1252 es el usado, la primera línea de tu código fuente debe ser:
 # -*- coding: cp-1252 -*
Una excepción a la regla de la primera línea es cuando el código fuente comienza con UNIX "shebang" line. En este caso, la
 declaración del encoding debe ser agregada como la segunda línea del archivo. Por ejempo:
 6
#!/usr/bin/env python3
 # -*- coding: cp-1252 -*
1
 En Unix, el intérprete de Python 3.x no se instala por default con el ejecutable llamado python para que no
 conflictúe con un ejecutable de Python 2.x que esté instalado simultaneamente.
 7
Una introducción informal a Python
 En los siguientes ejemplos, las entradas y salidas son distinguidas por la presencia o ausencia de los prompts (>>> y ...):
 para reproducir los ejemplos, debés escribir todo lo que esté después del prompt, cuando este aparezca; las líneas que no
 comiencen con el prompt son las salidas del intérprete. Tené en cuenta que el prompt secundario que aparece por si sólo en
 una línea de un ejemplo significa que debés escribir una línea en blanco; esto es usado para terminar un comando
 multilínea.
 Muchos de los ejemplos de este manual, incluso aquellos ingresados en el prompt interactivo, incluyen comentarios. Los
 comentarios en Python comienzan con el carácter numeral, #, y se extienden hasta el final físico de la línea. Un comentario
 quizás aparezca al comienzo de la línea o seguidos de espacios blancos o código, pero no dentro de una cadena de
 caracteres. Un carácter numeral dentro de una cadena de caracteres es sólo un carácter numeral. Ya que los comentarios
 son para aclarar código y no son interpretados por Python, pueden omitirse cuando se escriben los ejemplos.
 Algunos ejemplos:
 # este es el primer comentario
 spam = 1                 # y este es el segundo comentario
                         # ... y ahora un tercero!
 text = "# Este no es un comentario".
 Usar Python como una calculadora
 Vamos a probar algunos comandos simples en Python. Iniciá un intérprete y esperá por el prompt primario, >>>. (No debería
 demorar tanto).
 Números
 El intérprete actúa como una simple calculadora; podés ingresar una expresión y este escribirá los valores. La sintaxis es
 sencilla: los operadores +, -, * y / funcionan como en la mayoría de los lenguajes (por ejemplo, Pascal o C); los paréntesis
 (()) pueden ser usados para agrupar. Por ejemplo:
 >>> 2 + 2
 4
 >>> 50 - 5*6
 20
 >>> (50 - 5*6) / 4
 5.0
 >>> 8 / 5  # la división simpre retorna un número de punto flotante
 1.6
 Los números enteros (por ejemplo 2, 4, 20) son de tipo int, aquellos con una parte fraccional (por ejemplo 5.0, 1.6) son
 de tipo float. Vamos a ver más sobre tipos de números luego en este tutorial.
 La división (/) siempre retorna un punto flotante. Para hacer floor division y obtener un resultado entero (descartando
 cualquier resultado fraccional) podés usar el operador //; para calcular el resto podés usar %:
 >>> 17 / 3  # la división clásica retorna un punto flotante
 5.666666666666667
 >>>
 >>> 17 // 3  # la división entera descarta la parte fraccional
 5
 8
>>> 17 % 3  # el operado % retorna el resto de la división
 2
 >>> 5 * 3 + 2  # resultado * divisor + resto
 17
 Con Python, es posible usar el operador ** para calcular potencias 2:
 >>> 5 ** 2  # 5 al cuadrado
 25
 >>> 2 ** 7  # 2 a la potencia de 7
 128
 El signo igual (=) es usado para asignar un valor a una variable. Luego, ningún resultado es mostrado antes del próximo
 prompt:
 >>> ancho = 20
 >>> largo = 5 * 9
 >>> ancho * largo
 900
 Si una variable no está "definida" (con un valor asignado), intentar usarla producirá un error:
 >>> n  # tratamos de acceder a una variable no definida
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 NameError: name 'n' is not defined
 Hay soporte completo de punto flotante; operadores con operando mezclados convertirán los enteros a punto flotante:
 >>> 4 * 3.75 - 1
 14.0
 En el modo interactivo, la última expresión impresa es asignada a la variable _. Esto significa que cuando estés usando
 Python como una calculadora de escritorio, es más fácil seguir calculando, por ejemplo:
 >>> impuesto = 12.5 / 100
 >>> precio = 100.50
 >>> precio * impuesto
 12.5625
 >>> precio + _
 113.0625
 >>> round(_, 2)
 113.06
 Esta variable debería ser tratada como de sólo lectura por el usuario. No le asignes explícitamente un valor; crearás una
 variable local independiente con el mismo nombre enmascarando la variable con el comportamiento mágico.
 Además de int y float, Python soporta otros tipos de números, como ser Decimal y Fraction. Python también tiene
 soporte integrado para númreos complejos, y usa el sufijo j o J para indicar la parte imaginaria (por ejemplo 3+5j).
 Cadenas de caracteres
 Además de números, Python puede manipular cadenas de texto, las cuales pueden ser expresadas de distintas formas.
 Pueden estar encerradas en comillas simples ('...') o dobles ("...") con el mismo resultado 3. \ puede ser usado para
 escapar comillas:
 >>> 'huevos y pan'  # comillas simples
 'huevos y pan'
 >>> 'doesn\'t'  # usa \' para escapar comillas simples...
 "doesn't"
 9
>>> "doesn't"  # ...o de lo contrario usa comillas doblas
 "doesn't"
 >>> '"Si," le dijo.'
 '"Si," le dijo.'
 >>> "\"Si,\" le dijo."
 '"Si," le dijo.'
 >>> '"Isn\'t," she said.'
 '"Isn\'t," she said.'
 En el intéprete interactivo, la salida de cadenas está encerrada en comillas y los caracteres especiales son escapados con
 barras invertidas. Aunque esto a veces luzca diferente de la entrada (las comillas que encierran pueden cambiar), las dos
 cadenas son equivalentes. La cadena se encierra en comillas dobles si la cadena contiene una comilla simple y ninguna
 doble, de lo contrario es encerrada en comillas simples. La función print() produce una salida más legible, omitiendo las
 comillas que la encierran e imprimiendo caracteres especiales y escapados:
 >>> '"Isn\'t," she said.'
 '"Isn\'t," she said.'
 >>> print('"Isn\'t," she said.')
 "Isn't," she said.
 >>> s = 'Primerea línea.\nSegunda línea.'  # \n significa nueva línea
 >>> s  # sin print(), \n es incluído en la salida
 'Primera línea.\nSegunda línea.'
 >>> print(s)  # con print(), \n produce una nueva línea
 Primera línea.
 Segunda línea.
 Si no querés que los caracteres antepuestos por \ sean interpretados como caracteres especiales, podés usar cadenas
 crudas agregando una r antes de la primera comilla:
 >>> print('C:\algun\nombre')  # aquí \n significa nueva línea!
 C:\algun
 ombre
 >>> print(r'C:\algun\nombre')  # nota la r antes de la comilla
 C:\algun\nombre
 Las cadenas de texto literales pueden contener múltiples líneas. Una forma es usar triple comillas: """...""" o
 '''...'''. Los fin de línea son incluídos automáticamente, pero es posible prevenir esto agregando una \ al final de la
 línea. Por ejemplo:
 print("""\
 Uso: algo [OPTIONS]
     -h                        Muestra el mensaje de uso
     -H nombrehost             Nombre del host al cual conectarse
 """)
 produce la siguiente salida: (nota que la línea inicial no está incluída)
 Uso: algo [OPTIONS]
     -h                        Muestra el mensaje de uso
     -H nombrehost             Nombre del host al cual conectarse
 Las cadenas de texto pueden ser concatenadas (pegadas juntas) con el operador + y repetidas con *:
 >>> # 3 veces 'un', seguido de 'ium'
 >>> 3 * 'un' + 'ium'
 'unununium'
 Dos o más cadenas literales (aquellas encerradas entre comillas) una al lado de la otra son automáticamente concatenadas:
 10
>>> 'Py' 'thon'
 'Python'
 Esto solo funciona con dos literales, no con variables ni expresiones:
 >>> prefix = 'Py'
 >>> prefix 'thon'  # no se puede concatenar una variable y una cadena literal
  ...
 SyntaxError: invalid syntax
 >>> ('un' * 3) 'ium'
  ...
 SyntaxError: invalid syntax
 Si querés concatenar variables o una variable con un literal, usá +:
 >>> prefix + 'thon'
 'Python'
 Esta característica es particularmente útil cuando querés separar cadenadas largas:
 >>> texto = ('Poné muchas cadenas dentro de paréntesis '
 ...          'para que ellas sean unidas juntas.')
 >>> texto
 'Poné muchas cadenas dentro de paréntesis para que ellas sean unidas juntas.'
 Las cadenas de texto se pueden indexar (subíndices), el primer carácter de la cadena tiene el índice 0. No hay un tipo de
 dato para los caracteres; un carácter es simplemente una cadena de longitud uno:
 >>> palabra = 'Python'
 >>> palabra[0]  # caracter en la posición 0
 'P'
 >>> palabra[5]  # caracter en la posición 5
 'n'
 Los índices quizás sean números negativos, para empezar a contar desde la derecha:
 >>> palabra[-1]  # último caracter
 'n'
 >>> palabra[-2]  # ante último caracter
 'o'
 >>> palabra[-6]
 'P'
 Nota que -0 es lo mismo que 0, los índice negativos comienzan desde -1.
 Además de los índices, las rebanadas también están soportadas. Mientras que los índices son usados para obtener
 caracteres individuales, las rebanadas te permiten obtener sub-cadenas:
 >>> palabra[0:2]  # caracteres desde la posición 0 (incluída) hasta la 2 (excluída)
 'Py'
 >>> palabra[2:5]  # caracteres desde la posición 2 (incluída) hasta la 5 (excluída)
 'tho'
 Nota como el primero es siempre incluído, y que el último es siempre excluído. Esto asegura que s[:i] + s[i:] siempre
 sea igual a s:
 >>> palabra[:2] + palabra[2:]
 'Python'
 >>> palabra[:4] + palabra[4:]
 'Python'
 11
Los índices de las rebanadas tienen valores por defecto útiles; el valor por defecto para el primer índice es cero, el valor por
 defecto para el segundo índice es la longitud de la cadena a rebanar.
 >>> palabra[:2]  # caracteres desde el principio hasta la posición 2 (excluída)
 'Py'
 >>> palabra[4:]  # caracterrs desde la posición 4 (incluída) hasta el final
 'on'
 >>> palabra[-2:] # caracteres desde la ante-última (incluída) hasta el final
 'on'
 Una forma de recordar cómo funcionan las rebanadas es pensar en los índices como puntos entre caracteres, con el punto a
 la izquierda del primer carácter numerado en 0. Luego, el punto a la derecha del último carácter de una cadena de n
 caracteres tienen índice n, por ejemplo:
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6-6  -5  -4  -3  -2  -1
 La primer fila de números da la posición de los índices 0...6 en la cadena; la segunda fila da los correspondientes índices
 negativos. La rebanada de i a j consiste en todos los caracteres entre los puntos etiquetados i y j, respectivamente.
 Para índices no negativos, la longitud de la rebanada es la diferencia de los índices, si ambos entran en los límites. Por
 ejemplo, la longitud de palabra[1:3] es 2.
 Intentar usar un índice que es muy grande resultará en un error:
 >>> palabra[42]  # la palabra solo tiene 6 caracteres
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 IndexError: string index out of range
 Sin embargo, índices fuera de rango en rebanadas son manejados satisfactoriamente:
 >>> palabra[4:42]
 'on'
 >>> palabra[42:]
 ''
 Las cadenas de Python no pueden ser modificadas -- son immutable. Por eso, asignar a una posición indexada de la cadena
 resulta en un error:
 >>> palabra[0] = 'J'
  ...
 TypeError: 'str' object does not support item assignment
 >>> palabra[2:] = 'py'
  ...
 TypeError: 'str' object does not support item assignment
 Si necesitás una cadena diferente, deberías crear una nueva:
 >>> 'J' + palabra[1:]
 'Jython'
 >>> palabra[:2] + 'py'
 'Pypy'
 La función incorporada len() devuelve la longitud de una cadena de texto:
 12
>>> s = 'supercalifrastilisticoespialidoso'
 >>> len(s)
 33
 Ver también
 Tipos integrados
 Las cadenas de texto son ejemplos de tipos secuencias, y soportan las operaciones comunes para esos tipos.
 Tipos integrados
 Las cadenas de texto soportan una gran cantidad de métodos para transformaciones básicas y búsqueda.
 f-strings
 Literales de cadena que tienen expresiones embebidas.
 formatstrings
 Aquí se da información sobre formateo de cadenas de texto con str.format().
 Tipos integrados
 Aquí se describe con más detalle las operaciones viejas para formateo usadas cuando una cadena de texto están a
 la izquierda del operador %.
 Listas
 Python tiene varios tipos de datos compuestos, usados para agrupar otros valores. El más versátil es la lista, la cual puede
 ser escrita como una lista de valores separados por coma (ítems) entre corchetes. Las listas pueden contener ítems de
 diferentes tipos, pero usualmente los ítems son del mismo tipo:
 >>> cuadrados = [1, 4, 9, 16, 25]
 >>> cuadrados
 [1, 4, 9, 16, 25]
 Como las cadenas de caracteres (y todos los otros tipos sequence integrados), las listas pueden ser indexadas y rebanadas:
 >>> cuadrados[0]  # índices retornan un ítem
 1
 >>> cuadrados[-1]
 25
 >>> cuadrados[-3:]  # rebanadas retornan una nueva lista
 [9, 16, 25]
 Todas las operaciones de rebanado devuelven una nueva lista conteniendo los elementos pedidos. Esto significa que la
 siguiente rebanada devuelve una copia superficial de la lista:
 >>> cuadrados[:]
 [1, 4, 9, 16, 25]
 Las listas también soportan operaciones como concatenación:
 >>> cuadrados + [36, 49, 64, 81, 100]
 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
 A diferencia de las cadenas de texto, que son immutable, las listas son un tipo mutable, es posible cambiar un su contenido:
 >>> cubos = [1, 8, 27, 65, 125]  # hay algo mal aquí
 >>> 4 ** 3  # el cubo de 4 es 64, no 65!
 64
 13
>>> cubos[3] = 64  # reemplazar el valor incorrecto
 >>> cubos
 [1, 8, 27, 64, 125]
 También podés agregar nuevos ítems al final de la lista, usando el método append() (vamos a ver más sobre los métodos
 luego):
 >>> cubos.append(216)  # agregar el cubo de 6
 >>> cubos.append(7 ** 3)  # y el cubo de 7
 >>> cubos
 [1, 8, 27, 64, 125, 216, 343]
 También es posible asignar a una rebanada, y esto incluso puede cambiar la longitud de la lista o vaciarla totalmente:
 >>> letras = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 >>> letras
 ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 >>> # reemplazar algunos valores
 >>> letras[2:5] = ['C', 'D', 'E']
 >>> letras
 ['a', 'b', 'C', 'D', 'E', 'f', 'g']
 >>> # ahora borrarlas
 >>> letras[2:5] = []
 >>> letras
 ['a', 'b', 'f', 'g']
 >>> # borrar la lista reemplzando todos los elementos por una lista vacía
 >>> letras[:] = []
 >>> letras
 []
 La función predefinida len() también sirve para las listas:
 >>> letras = ['a', 'b', 'c', 'd']
 >>> len(letras)
 4
 Es posible anidar listas (crear listas que contengan otras listas), por ejemplo:
 >>> a = ['a', 'b', 'c']
 >>> n = [1, 2, 3]
 >>> x = [a, n]
 >>> x
 [['a', 'b', 'c'], [1, 2, 3]]
 >>> x[0]
 ['a', 'b', 'c']
 >>> x[0][1]
 'b'
 Primeros pasos hacia la programación
 Por supuesto, podemos usar Python para tareas más complicadas que sumar dos y dos. Por ejemplo, podemos escribir una
 subsecuencia inicial de la serie de Fibonacci así:
 >>> # Series de Fibonacci:
 ... # la suma de dos elementos define el siguiente
 ... a, b = 0, 1
 >>> while b < 10:
 ...     print(b)
 ...     a, b = b, a+b
 ...
 14
1
 1
 2
 3
 5
 8
 Este ejemplo introduce varias características nuevas.
 • La primer línea contiene una asignación múltiple: las variables a y b toman en forma simultanea los nuevos valores 0 y
 1. En la última linea esto se vuelve a usar, demostrando que las expresiones a la derecha son evaluadas antes de que
 suceda cualquier asignación. Las expresiones a la derecha son evaluadas de izquierda a derecha.
 •
 El bucle while se ejecuta mientras la condición (aquí: b < 10) sea verdadera. En Python, como en C, cualquier
 entero distinto de cero es verdadero; cero es falso. La condición también puede ser una cadena de texto o una lista, de
 hecho cualquier secuencia; cualquier cosa con longitud distinta de cero es verdadero, las secuencias vacías son
 falsas. La prueba usada en el ejemplo es una comparación simple. Los operadores estándar de comparación se
 escriben igual que en C: < (menor qué), > (mayor qué), == (igual a), <= (menor o igual qué), >= (mayor o igual qué) y
 != (distinto a).
 • El cuerpo del bucle está sangrado: la sangría es la forma que usa Python para agrupar declaraciones. En el intérprete
 interactivo debés teclear un tab o espacio(s) para cada línea sangrada. En la práctica vas a preparar entradas más
 complicadas para Python con un editor de texto; todos los editores de texto decentes tienen la facilidad de agregar la
 sangría automáticamente. Al ingresar una declaración compuesta en forma interactiva, debés finalizar con una línea en
 blanco para indicar que está completa (ya que el analizador no puede adivinar cuando tecleaste la última línea). Notá
 que cada línea de un bloque básico debe estar sangrada de la misma forma.
 •
 La función print() escribe el valor de el o los argumentos que se le pasan. Difiere de simplemente escribir la
 expresión que se quiere mostrar (como hicimos antes en los ejemplos de la calculadora) en la forma en que maneja
 múltiples argumentos, cantidades en punto flotante, y cadenas. Las cadenas de texto son impresas sin comillas, y un
 espacio en blanco es insertado entre los elementos, así podés formatear cosas de una forma agradable:
 >>> i = 256*256
 >>> print('El valor de i es', i)
 El valor de i es 65536
 El parámetro nombrado end puede usarse para evitar el salto de linea al final de la salida, o terminar la salida con una
 cadena diferente:
 >>> a, b = 0, 1
 >>> while b < 1000:
 ...     
print(b, end=',')
 ...     
...
 a, b = b, a+b
 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
 2
 3
 Debido a que ** tiene mayor precedencia que -, -3**2 será interpretado como -(3**2) y eso da como
 resultado -9. Para evitar esto y obtener 9, podés usar (-3)**2.
 A diferencia de otros lenguajes, caracteres especiales como \n tiene el mismo significado con simple ('...') y
 doble ("...") comillas. La única diferencia entre las dos es que dentro de las comillas simples no tenés la
 necesitada de escapar " (pero tenés que escapar \') y viceversa.
 15
Más herramientas para control de 
flujo
 Además de la sentencia while que acabamos de introducir, Python soporta las sentencias de control de flujo que podemos
 encontrar en otros lenguajes, con algunos cambios.
 La sentencia 
Tal vez el tipo más conocido de sentencia sea el if. Por ejemplo:
 >>> x = int(input("Ingresa un entero, por favor: "))
 Ingresa un entero, por favor: 42
 >>> if x < 0:
 ...      x = 0
 ...      print('Negativo cambiado a cero')
 ... elif x == 0:
 ...      print('Cero')
 ... elif x == 1:
 ...      print('Simple')
 ... else:
 ...      print('Más')
 ...
 'Mas'
 Puede haber cero o más bloques elif, y el bloque else es opcional. La palabra reservada 'elif' es una abreviación de
 'else if', y es útil para evitar un sangrado excesivo. Una secuencia if ... elif ... elif ... sustituye las sentencias switch o
 case encontradas en otros lenguajes.
 La sentencia 
La sentencia for en Python difiere un poco de lo que uno puede estar acostumbrado en lenguajes como C o Pascal. En
 lugar de siempre iterar sobre una progresión aritmética de números (como en Pascal) o darle al usuario la posibilidad de
 definir tanto el paso de la iteración como la condición de fin (como en C), la sentencia for de Python itera sobre los ítems de
 cualquier secuencia (una lista o una cadena de texto), en el orden que aparecen en la secuencia. Por ejemplo:
 >>> # Midiendo cadenas de texto
 ... palabras = ['gato', 'ventana', 'defenestrado']
 >>> for p in palabras:
 ...     print(p, len(p))
 ...
 gato 4
 ventana 7
 defenestrado 12
 Si necesitás modificar la secuencia sobre la que estás iterando mientras estás adentro del ciclo (por ejemplo para borrar
 algunos ítems), se recomienda que hagas primero una copia. Iterar sobre una secuencia no hace implícitamente una copia.
 La notación de rebanada es especialmente conveniente para esto:
 >>> for p in palabras[:]:  # hace una copia por rebanada de toda la lista
 ...    if len(p) > 6:
 ...        palabras.insert(0, p)
 ...
 16
>>> palabras
 ['defenestrado', 'ventana', 'gato', 'ventana', 'defenestrado']
 Con for w in words:, el ejemplo intentaría crear una lista infinita, insertando defenestrado una y otra vez.
 La función 
Si se necesita iterar sobre una secuencia de números, es apropiado utilizar la función integrada range(), la cual genera
 progresiones aritméticas:
 >>> for i in range(5):
 ...     print(i)
 ...
 0
 1
 2
 3
 4
 El valor final dado nunca es parte de la secuencia; range(10) genera 10 valores, los índices correspondientes para los
 ítems de una secuencia de longitud 10. Es posible hacer que el rango empiece con otro número, o especificar un incremento
 diferente (incluso negativo; algunas veces se lo llama 'paso'):
 range(5, 10)
   5 through 9
 range(0, 10, 3)
   0, 3, 6, 9
 range(-10, -100, -30)
  -10, -40, -70
 Para iterar sobre los índices de una secuencia, podés combinar range() y len() así:
 >>> a = ['Mary', 'tenia', 'un', 'corderito']
 >>> for i in range(len(a)):
 ...     print(i, a[i])
 ...
 0 Mary
 1 tenia
 2 un
 3 corderito
 En la mayoría de los casos, sin embargo, conviene usar la función enumerate(), mirá Técnicas de iteración.
 Algo extraño sucede si mostrás un range:
 >>> print(range(10))
 range(0, 10)
 De muchas maneras el objeto devuelto por range() se comporta como si fuera una lista, pero no lo es. Es un objeto que
 devuelve los ítems sucesivos de la secuencia deseada cuando iterás sobre él, pero realmente no construye la lista,
 ahorrando entonces espacio.
 Decimos que tal objeto es iterable; esto es, que se lo puede usar en funciones y construcciones que esperan algo de lo cual
 obtener ítems sucesivos hasta que se termine. Hemos visto que la declaración for es un iterador en ese sentido. La función
 list() es otra; crea listas a partir de iterables:
 17
>>> list(range(5))
 [0, 1, 2, 3, 4]
 Más tarde veremos más funciones que devuelven iterables y que toman iterables como entrada.
 Las sentencias , , y  en lazos
 La sentencia break, como en C, termina el lazo for o while más anidado.
 Las sentencias de lazo pueden tener una cláusula else que es ejecutada cuando el lazo termina, luego de agotar la lista
 (con for) o cuando la condición se hace falsa (con while), pero no cuando el lazo es terminado con la sentencia break. Se
 ejemplifica en el siguiente lazo, que busca números primos:
 >>> for n in range(2, 10):
 ...     for x in range(2, n):
 ...         if n % x == 0:
 ...             print(n, 'es igual a', x, '*', n/x)
 ...             break
 ...     else:
 ...         # sigue el bucle sin encontrar un factor
 ...         print(n, 'es un numero primo')
 ...
 2 es un numero primo
 3 es un numero primo
 4 es igual a 2 * 2
 5 es un numero primo
 6 es igual a 2 * 3
 7 es un numero primo
 8 es igual a 2 * 4
 9 es igual a 3 * 3
 (Sí, este es el código correcto. Fijate bien: el else pertenece al ciclo for, no al if.)
 Cuando se usa con un ciclo, el else tiene más en común con el else de una declaración try que con el de un if: el else
 de un try se ejecuta cuando no se genera ninguna excepción, y el else de un ciclo se ejecuta cuando no hay ningún
 break. Para más sobre la declaración try y excepciones, mirá Manejando excepciones.
 La declaración continue, también tomada de C, continua con la siguiente iteración del ciclo:
 >>> for num in range(2, 10):
 ...     if num % 2 == 0:
 ...         print("Encontré un número par", num)
 ...         continue
 ...     print("Encontré un número", num)
 Encontré un número par 2
 Encontré un número 3
 Encontré un número par 4
 Encontré un número 5
 Encontré un número par 6
 Encontré un número 7
 Encontré un número par 8
 Encontré un número 9
 La sentencia 
La sentencia pass no hace nada. Se puede usar cuando una sentencia es requerida por la sintáxis pero el programa no
 requiere ninguna acción. Por ejemplo:
 18
>>> while True:
 ...     
pass  # Espera ocupada hasta una interrupción de teclado (Ctrl+C)
 ...
 Se usa normalmente para crear clases en su mínima expresión:
 >>> class MyEmptyClass:
 ...     
pass
 ...
 Otro lugar donde se puede usar pass es como una marca de lugar para una función o un cuerpo condicional cuando estás
 trabajando en código nuevo, lo cual te permite pensar a un nivel de abstracción mayor. El pass se ignora silenciosamente:
 >>> def initlog(*args):
 ...     
pass   # Acordate de implementar esto!
 ...
 Definiendo funciones
 Podemos crear una función que escriba la serie de Fibonacci hasta un límite determinado:
 >>> def fib(n):  # escribe la serie de Fibonacci hasta n
 ...     
"""Escribe la serie de Fibonacci hasta n."""
 ...     
...     
...         
...         
...     
a, b = 0, 1
 while a < n:
 print(a, end=' ')
 a, b = b, a+b
 print()
 ...
 >>> # Ahora llamamos a la funcion que acabamos de definir:
 ... fib(2000)
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
 La palabra reservada def se usa para definir funciones. Debe seguirle el nombre de la función y la lista de parámetros
 formales entre paréntesis. Las sentencias que forman el cuerpo de la función empiezan en la línea siguiente, y deben estar
 con sangría.
 La primer sentencia del cuerpo de la función puede ser opcionalmente una cadena de texto literal; esta es la cadena de texto
 de documentación de la función, o docstring. (Podés encontrar más acerca de docstrings en la sección Cadenas de texto de
 documentación.)
 Hay herramientas que usan las docstrings para producir automáticamente documentación en línea o imprimible, o para
 permitirle al usuario que navegue el código en forma interactiva; es una buena práctica incluir docstrings en el código que
 uno escribe, por lo que se debe hacer un hábito de esto.
 La ejecución de una función introduce una nueva tabla de símbolos usada para las variables locales de la función. Más
 precisamente, todas las asignaciones de variables en la función almacenan el valor en la tabla de símbolos local; así mismo
 la referencia a variables primero mira la tabla de símbolos local, luego en la tabla de símbolos local de las funciones
 externas, luego la tabla de símbolos global, y finalmente la tabla de nombres predefinidos. Así, no se les puede asignar
 directamente un valor a las variables globales dentro de una función (a menos se las nombre en la sentencia global),
 aunque si pueden ser referenciadas.
 Los parámetros reales (argumentos) de una función se introducen en la tabla de símbolos local de la función llamada cuando
 esta es ejecutada; así, los argumentos son pasados por valor (dónde el valor es siempre una referencia a un objeto, no el
 valor del objeto). 4 Cuando una función llama a otra función, una nueva tabla de símbolos local es creada para esa llamada.
 La definición de una función introduce el nombre de la función en la tabla de símbolos actual. El valor del nombre de la
 función tiene un tipo que es reconocido por el interprete como una función definida por el usuario. Este valor puede ser
 19
asignado a otro nombre que luego puede ser usado como una función. Esto sirve como un mecanismo general para
 renombrar:
 >>> fib
 <function fib at 10042ed0>
 >>> f = fib
 >>> f(100)
 0 1 1 2 3 5 8 13 21 34 55 89
 Viniendo de otros lenguajes, podés objetar que fib no es una función, sino un procedimiento, porque no devuelve un valor.
 De hecho, técnicamente hablando, los procedimientos sí retornan un valor, aunque uno aburrido. Este valor se llama None
 (es un nombre predefinido). El intérprete por lo general no escribe el valor None si va a ser el único valor escrito. Si
 realmente se quiere, se puede verlo usando la función print():
 >>> fib(0)
 >>> print(fib(0))
 None
 Es simple escribir una función que retorne una lista con los números de la serie de Fibonacci en lugar de imprimirlos:
 >>> def fib2(n): # devuelve la serie de Fibonacci hasta n
 ...     """Devuelve una lista conteniendo la serie de Fibonacci hasta n."""
 ...     result = []
 ...     a, b = 0, 1
 ...     while a < n:
 ...         result.append(a)    # ver abajo
 ...         a, b = b, a+b
 ...     return result
 ...
 >>> f100 = fib2(100)    # llamarla
 >>> f100                # escribir el resultado
 [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
 Este ejemplo, como es usual, demuestra algunas características más de Python:
 •La sentencia return devuelve un valor en una función. return sin una expresión como argumento retorna None. Si
 se alcanza el final de una función, también se retorna None.
 •La sentencia result.append(a) llama a un método del objeto lista result. Un método es una función que
 'pertenece' a un objeto y se nombra obj.methodname, dónde obj es algún objeto (puede ser una expresión), y
 methodname es el nombre del método que está definido por el tipo del objeto. Distintos tipos definen distintos
 métodos. Métodos de diferentes tipos pueden tener el mismo nombre sin causar ambigüedad. (Es posible definir tipos
 de objetos propios, y métodos, usando clases, mirá Clases). El método append() mostrado en el ejemplo está
 definido para objetos lista; añade un nuevo elemento al final de la lista. En este ejemplo es equivalente a
 result = result + [a], pero más eficiente.
 Más sobre definición de funciones
 También es posible definir funciones con un número variable de argumentos. Hay tres formas que pueden ser combinadas.
 Argumentos con valores por omisión
 La forma más útil es especificar un valor por omisión para uno o más argumentos. Esto crea una función que puede ser
 llamada con menos argumentos que los que permite. Por ejemplo:
 def pedir_confirmacion(prompt, reintentos=4, recordatorio='Por favor, intente nuevamente!'):
    while True:
        ok = input(prompt)
        if ok in ('s', 'S', 'si', 'Si', 'SI'):
 20
            return True
        if ok in ('n', 'no', 'No', 'NO'):
            return False
        reintentos = reintentos - 1
        if reintentos < 0:
            raise ValueError('respuesta de usuario inválida')
        print(recordatorio)
 Esta función puede ser llamada de distintas maneras:
 •pasando sólo el argumento obligatorio: pedir_confirmacion('¿Realmente queres salir?')
 •pasando uno de los argumentos opcionales: pedir_confirmacion('¿Sobreescribir archivo?', 2)
 •o pasando todos los argumentos:
 pedir_confirmacion('¿Sobreescribir archivo?', 2, "Vamos, solo si o no!)
 Este ejemplo también introduce la palabra reservada in, la cual prueba si una secuencia contiene o no un determinado
 valor.
 Los valores por omisión son evaluados en el momento de la definición de la función, en el ámbito de la definición, entonces:
 i = 5
 def f(arg=i):
    print(arg)
 i = 6
 f()
 ...imprimirá 5.
 Advertencia importante: El valor por omisión es evaluado solo una vez. Existe una diferencia cuando el valor por omisión
 es un objeto mutable como una lista, diccionario, o instancia de la mayoría de las clases. Por ejemplo, la siguiente función
 acumula los argumentos que se le pasan en subsiguientes llamadas:
 def f(a, L=[]):
    L.append(a)
    return L
 print(f(1))
 print(f(2))
 print(f(3))
 Imprimirá:
 [1]
 [1, 2]
 [1, 2, 3]
 Si no se quiere que el valor por omisión sea compartido entre subsiguientes llamadas, se pueden escribir la función así:
 def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
 21
Palabras claves como argumentos
 Las funciones también puede ser llamadas usando argumentos de palabras clave (o argumentos nombrados) de la forma
 keyword = value. Por ejemplo, la siguiente función:
 def loro(tension, estado='muerto', accion='explotar', tipo='Azul Nordico'):
    print("-- Este loro no va a", accion, end=' ')
    print("si le aplicás", tension, "voltios.")
    print("-- Gran plumaje tiene el", tipo)
    print("-- Está", estado, "!")
 ...acepta un argumento obligatorio (tension) y tres argumentos opcionales (estado, accion, y tipo). Esta función puede
 llamarse de cualquiera de las siguientes maneras:
 loro(1000)                                          # 1 argumento posicional
 loro(tension=1000)                                  # 1 argumento nombrado
 loro(tension=1000000, accion='VOOOOOM')             # 2 argumentos nombrados
 loro(accion='VOOOOOM', tension=1000000)             # 2 argumentos nombrados
 loro('un millón', 'despojado de vida', 'saltar')    # 3 args posicionales
 loro('mil', estado='viendo crecer las flores desde abajo')  # uno y uno
 ...pero estas otras llamadas serían todas inválidas:
 loro()                      # falta argumento obligatorio
 loro(tension=5.0, 'muerto') # argumento posicional luego de uno nombrado
 loro(110, tension=220)      # valor duplicado para el mismo argumento
 loro(actor='Juan Garau')    # nombre del argumento desconocido
 En una llamada a una función, los argumentos nombrados deben seguir a los argumentos posicionales. Cada uno de los
 argumentos nombrados pasados deben coincidir con un argumento aceptado por la función (por ejemplo, actor no es un
 argumento válido para la función loro), y el orden de los mismos no es importante. Esto también se aplica a los argumentos
 obligatorios (por ejemplo, loro(tension=1000) también es válido). Ningún argumento puede recibir más de un valor al
 mismo tiempo. Aquí hay un ejemplo que falla debido a esta restricción:
 >>> def funcion(a):
 ...     pass
 ...
 >>> funcion(0, a=0)
 Traceback (most recent call last):
 ...
 TypeError: funcion() got multiple values for keyword argument 'a'
 Cuando un parámetro formal de la forma **nombre está presente al final, recibe un diccionario (ver Tipos integrados)
 conteniendo todos los argumentos nombrados excepto aquellos correspondientes a un parámetro formal. Esto puede ser
 combinado con un parámetro formal de la forma *nombre (descripto en la siguiente sección) que recibe una tupla
 conteniendo los argumentos posicionales además de la lista de parámetros formales. (*nombre debe ocurrir antes de
 **nombre). Por ejemplo, si definimos una función así:
 def ventadequeso(tipo, *argumentos, **palabrasclaves):
    print("-- ¿Tiene", tipo, "?")
    print("-- Lo siento, nos quedamos sin", tipo)
    for arg in argumentos:
        print(arg)
    print("-" * 40)
    for c in palabrasclaves:
        print(c, ":", palabrasclaves[c])
 Puede ser llamada así:
 22
ventadequeso("Limburger", "Es muy liquido, sr.",
             "Realmente es muy muy liquido, sr.",
             cliente="Juan Garau",
             vendedor="Miguel Paez",
             puesto="Venta de Queso Argentino")
 ...y por supuesto imprimirá:
 .. code-block:: none-- ¿Tiene Limburger ? -- Lo siento, nos quedamos sin Limburger Es muy liquido, sr. Realmente es muy muy liquido, sr.---------------------------------------- cliente : Juan Garau vendedor : Miguel Paez puesto : Venta de Queso Argentino
 Se debe notar que el orden en el cual los argumentos nombrados son impresos está garantizado para coincidir con el orden
 en el cual fueron provistos en la llamada a la función.
 Listas de argumentos arbitrarios
 Finalmente, la opción menos frecuentemente usada es especificar que una función puede ser llamada con un número
 arbitrario de argumentos. Estos argumentos serán organizados en una tupla (mirá Tuplas y secuencias). Antes del número
 variable de argumentos, cero o más argumentos normales pueden estar presentes.:
 def muchos_items(archivo, separador, *args):
    archivo.write(separador.join(args))
 Normalmente estos argumentos de cantidad variables son los últimos en la lista de parámetros formales, porque toman todo
 el remanente de argumentos que se pasan a la función. Cualquier parámetro que suceda luego del *args será 'sólo
 nombrado', o sea que sólo se pueden usar como nombrados y no posicionales.:
 >>> def concatenar(*args, sep="/"):
 ...     return sep.join(args)
 ...
 >>> concatenar("tierra", "marte", "venus")
 'tierra/marte/venus'
 >>> concatenar("tierra", "marte", "venus", sep=".")
 'tierra.marte.venus'
 Desempaquetando una lista de argumentos
 La situación inversa ocurre cuando los argumentos ya están en una lista o tupla pero necesitan ser desempaquetados para
 llamar a una función que requiere argumentos posicionales separados. Por ejemplo, la función predefinida range() espera
 los argumentos inicio y fin. Si no están disponibles en forma separada, se puede escribir la llamada a la función con el
 operador para desempaquetar argumentos de una lista o una tupla *::
 >>> list(range(3, 6))   # llamada normal con argumentos separados
 [3, 4, 5]
 >>> args = [3, 6]
 >>> list(range(*args))  # llamada con argumentos desempaquetados de la lista
 [3, 4, 5]
 Del mismo modo, los diccionarios pueden entregar argumentos nombrados con el operador **::
 >>> def loro(tension, estado='rostizado', accion='explotar'):
 ...     print("-- Este loro no va a", accion, end=' ')
 ...     print("si le aplicás", tension, "voltios.", end=' ')
 ...     print("Está", estado, "!")
 ...
 >>> d = {"tension": "cinco mil", "estado": "demacrado",
 ...      "accion": "VOLAR"}
 23
>>> loro(**d)-- Este loro no va a VOLAR si le aplicás cinco mil voltios. Está demacrado !
 Expresiones lambda
 Pequeñas funciones anónimas pueden ser creadas con la palabra reservada lambda. Esta función retorna la suma de sus
 dos argumentos: lambda a, b: a + b. Las funciones Lambda pueden ser usadas en cualquier lugar donde sea
 requerido un objeto de tipo función. Están sintácticamente restringidas a una sola expresión. Semánticamente, son solo
 azúcar sintáctica para definiciones normales de funciones. Al igual que las funciones anidadas, las funciones lambda pueden
 hacer referencia a variables desde el ámbito que la contiene:
 >>> def hacer_incrementador(n):
 ...     
return lambda x: x + n
 ...
 >>> f = hacer_incrementador(42)
 >>> f(0)
 42
 >>> f(1)
 43
 Cadenas de texto de documentación
 Acá hay algunas convenciones sobre el contenido y formato de las cadenas de texto de documentación.
 La primer línea debe ser siempre un resumen corto y conciso del propósito del objeto. Para ser breve, no se debe mencionar
 explícitamente el nombre o tipo del objeto, ya que estos están disponibles de otros modos (excepto si el nombre es un verbo
 que describe el funcionamiento de la función). Esta línea debe empezar con una letra mayúscula y terminar con un punto.
 Si hay más líneas en la cadena de texto de documentación, la segunda línea debe estar en blanco, separando visualmente
 el resumen del resto de la descripción. Las líneas siguientes deben ser uno o más párrafos describiendo las convenciones
 para llamar al objeto, efectos secundarios, etc.
 El analizador de Python no quita el sangrado de las cadenas de texto literales multi-líneas, entonces las herramientas que
 procesan documentación tienen que quitarlo si así lo desean. Esto se hace mediante la siguiente convención. La primer línea
 que no está en blanco siguiente a la primer línea de la cadena determina la cantidad de sangría para toda la cadena de
 documentación. (No podemos usar la primer línea ya que generalmente es adyacente a las comillas de apertura de la
 cadena y el sangrado no se nota en la cadena de texto). Los espacios en blanco "equivalentes" a este sangrado son luego
 quitados del comienzo de cada línea en la cadena. No deberían haber líneas con una sangría menor, pero si las hay todos
 los espacios en blanco del comienzo deben ser quitados. La equivalencia de espacios en blanco debe ser verificada luego
 de la expansión de tabs (a 8 espacios, normalmente).
 Este es un ejemplo de un docstring multi-línea:
 >>> def mi_funcion():
 ...     
"""No hace mas que documentar la funcion.
 ...
 ... 
... 
...     
    No, de verdad. No hace nada.
    """
 pass
 ...
 >>> print(mi_funcion.__doc__)
 No hace mas que documentar la funcion.
 No, de verdad. No hace nada.
 Anotación de funciones
 +:ref:Function annotations <function> are completely optional metadata +information about the types used by user-defined
 functions (see PEP 484 +for more information).
 24
Las anotaciones de funciones son información completamente opcional sobre los tipos usadas en funciones definidas por el
 usuario (ver PEP 484 para más información).
 Las anotaciones se almacenan en el atributo __annotations__ de la función como un diccionario y no tienen efecto en
 ninguna otra parte de la función. Las anotaciones de los parámetros se definen luego de dos puntos después del nombre del
 parámetro, seguido de una expresión que evalúa al valor de la anotación. Las anotaciones de retorno son definidas por el
 literal ->, seguidas de una expresión, entre la lista de parámetros y los dos puntos que marcan el final de la declaración def.
 El siguiente ejemplo tiene un argumento posicional, uno nombrado, y el valor de retorno anotado:
 >>> def f(jamon: str, huevos: str = 'huevos') -> str:
 ...     
print("Anotaciones:", f.__annotations__)
 ...     
...     
print("Argumentos:", jamon, huevos)
 return jamon + ' y ' + huevos
 ...
 >>> f('carne')
 Anotaciones: {'jamon': <class 'str'>, 'huevos': <class 'str'>, 'return': <class 'str'>}
 Argumentos: carne huevos
 'carne y huevos'
 >>>
 Intermezzo: Estilo de codificación
 Ahora que estás a punto de escribir piezas de Python más largas y complejas, es un buen momento para hablar sobre estilo
 de codificación. La mayoría de los lenguajes pueden ser escritos (o mejor dicho, formateados) con diferentes estilos; algunos
 son mas fáciles de leer que otros. Hacer que tu código sea más fácil de leer por otros es siempre una buena idea, y adoptar
 un buen estilo de codificación ayuda tremendamente a lograrlo.
 Para Python, PEP 8 se erigió como la guía de estilo a la que más proyectos adhirieron; promueve un estilo de codificación
 fácil de leer y visualmente agradable. Todos los desarrolladores Python deben leerlo en algún momento; aquí están
 extraídos los puntos más importantes:
 • Usar sangrías de 4 espacios, no tabs.
 4 espacios son un buen compromiso entre una sangría pequeña (permite mayor nivel de sangrado)y una sangría
 grande (más fácil de leer). Los tabs introducen confusión y es mejor dejarlos de lado.
 • Recortar las líneas para que no superen los 79 caracteres.
 Esto ayuda a los usuarios con pantallas pequeñas y hace posible tener varios archivos de código abiertos, uno al lado
 del otro, en pantallas grandes.
 • Usar líneas en blanco para separar funciones y clases, y bloques grandes de código dentro de funciones.
 • Cuando sea posible, poner comentarios en una sola línea.
 • Usar docstrings.
 • Usar espacios alrededor de operadores y luego de las comas, pero no directamente dentro de paréntesis:
 a = f(1, 2) + g(3, 4).
 • Nombrar las clases y funciones consistentemente; la convención es usar NotacionCamello para clases y
 minusculas_con_guiones_bajos para funciones y métodos. Siempre usá self como el nombre para el primer
 argumento en los métodos (mirá Un primer vistazo a las clases para más información sobre clases y métodos).
 • No uses codificaciones estrafalarias si esperás usar el código en entornos internacionales. El default de Python,
 UTF-8, o incluso ASCII plano funcionan bien en la mayoría de los casos.
 4
 • De la misma manera, no uses caracteres no-ASCII en los identificadores si hay incluso una pequeñísima chance de
 que gente que hable otro idioma tenga que leer o mantener el código.
 En realidad, llamadas por referencia de objeto sería una mejor descripción, ya que si se pasa un objeto mutable,
 quien realiza la llamada verá cualquier cambio que se realice sobre el mismo (por ejemplo ítems insertados en una
 lista).
 25
Estructuras de datos
 Este capítulo describe algunas cosas que ya aprendiste en más detalle, y agrega algunas cosas nuevas también.
 Más sobre listas
 El tipo de dato lista tiene algunos métodos más. Aquí están todos los métodos de los objetos lista:
 list.append (x)
 Agrega un ítem al final de la lista. Equivale a a[len(a):] = [x].
 list.extend (iterable)
 Extiende la lista agregándole todos los ítems del iterable. Equivale a a[len(a):] = iterable.
 list.insert (i, x)
 Inserta un ítem en una posición dada. El primer argumento es el índice del ítem delante del cual se insertará, por lo tanto
 a.insert(0, x) inserta al principio de la lista, y a.insert(len(a), x) equivale a a.append(x).
 list.remove (x)
 Quita el primer ítem de la lista cuyo valor sea x. Es un error si no existe tal ítem.
 list.pop ([, i])
 Quita el ítem en la posición dada de la lista, y lo devuelve. Si no se especifica un índice, a.pop() quita y devuelve el
 último ítem de la lista. (Los corchetes que encierran a i en la firma del método denotan que el parámetro es opcional, no
 que deberías escribir corchetes en esa posición. Verás esta notación con frecuencia en la Referencia de la Biblioteca de
 Python.)
 list.clear ()
 Quita todos los elementos de la lista. Equivalente a del a[:].
 list.index (x[, start[, end]])
 Devuelve un índice basado en cero en la lista del primer ítem cuyo valor sea x. Levanta una excepción ValueError si no
 existe tal ítem.
 Los argumentos opcionales start y end son interpetados como la notación de rebanadas y se usan para limitar la
 búsqueda a una subsecuencia particular de la lista. El index retornado se calcula de manera relativa al inicio de la
 secuencia completa en lugar de con respecto al argumento start.
 list.count (x)
 Devuelve el número de veces que x aparece en la lista.
 list.sort (key=None, reverse=False)
 Ordena los ítems de la lista in situ (los argumentos pueden ser usados para personalizar el orden de la lista, ve sorted()
 para su explicación).
 list.reverse ()
 Invierte los elementos de la lista in situ.
 26
list.copy ()
 Devuelve una copia superficial de la lista. Equivalente a a[:].
 Un ejemplo que usa la mayoría de los métodos de lista:
 >>> frutas = ['naranja', 'manzana', 'pera', 'banana', 'kiwi', 'manzana', 'banana']
 >>> frutas.count('manzana')
 2
 >>> frutas.count('mandarina')
 0
 >>> frutas.index('banana')
 3
 >>> frutas.index('banana', 4)  # Find next banana starting a position 4
 6
 >>> frutas.reverse()
 >>> frutas
 ['banana', 'manzana', 'kiwi', 'banana', 'pera', 'manzana', 'naranja']
 >>> frutas.append('uva')
 >>> frutas
    ['banana', 'manzana', 'kiwi', 'banana', 'pera', 'manzana', 'naranja', 'uva']
 >>> frutas.sort()
 >>> frutas
 ['manzana', 'manzana', 'banana', 'banana', 'uva', 'kiwi', 'naranja', 'pera']
 >>> frutas.pop()
 'pera'
 Quizás hayas notado que métodos como insert, remove o sort, que solo modifican a la lista, no tienen impreso un valor
 de retorno -- devuelven None. 5 Esto es un principio de diseño para todas las estructuras de datos mutables en Python.
 Usando listas como pilas
 Los métodos de lista hacen que resulte muy fácil usar una lista como una pila, donde el último elemento añadido es el primer
 elemento retirado ("último en entrar, primero en salir"). Para agregar un ítem a la cima de la pila, use append(). Para retirar
 un ítem de la cima de la pila, use pop() sin un índice explícito. Por ejemplo:
 >>> stack = [3, 4, 5]
 >>> stack.append(6)
 >>> stack.append(7)
 >>> stack
 [3, 4, 5, 6, 7]
 >>> stack.pop()
 7
 >>> stack
 [3, 4, 5, 6]
 >>> stack.pop()
 6
 >>> stack.pop()
 5
 >>> stack
 [3, 4]
 Usando listas como colas
 También es posible usar una lista como una cola, donde el primer elemento añadido es el primer elemento retirado ("primero
 en entrar, primero en salir"); sin embargo, las listas no son eficientes para este propósito. Agregar y sacar del final de la lista
 es rápido, pero insertar o sacar del comienzo de una lista es lento (porque todos los otros elementos tienen que ser
 desplazados por uno).
 Para implementar una cola, usá collections.deque el cual fue diseñado para agregar y sacar de ambas puntas de forma
 rápida. Por ejemplo:
 27
>>> from collections import deque
 >>> queue = deque(["Eric", "John", "Michael"])
 >>> queue.append("Terry")         # llega Terry
 >>> queue.append("Graham")        # llega Graham
 >>> queue.popleft()               # el primero en llegar ahora se va
 'Eric'
 >>> queue.popleft()               # el segundo en llegar ahora se va
 'John'
 >>> queue                         # el resto de la cola en órden de llegada
 ['Michael', 'Terry', 'Graham']
 Comprensión de listas
 Las comprensiones de listas ofrecen una manera concisa de crear listas. Sus usos comunes son para hacer nuevas listas
 donde cada elemento es el resultado de algunas operaciones aplicadas a cada miembro de otra secuencia o iterable, o para
 crear una subsecuencia de esos elementos para satisfacer una condición determinada.
 Por ejemplo, asumamos que queremos crear una lista de cuadrados, como:
 >>> cuadrados = []
 >>> for x in range(10):
 ...     cuadrados.append(x**2)
 ...
 >>> cuadrados
 [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
 Nota que esto crea (o sobreescribe) una variable llamada x que sigue existiendo luego de que el bucle haya terminado.
 Podemos calcular la lista de cuadrados sin ningun efecto secundario haciendo:
 cuadrados = list(map(lambda x: x**2, range(10)))
 o, un equivalente:
 cuadrados = [x ** 2 for x in range(10)]
 que es más conciso y legible.
 Una lista de comprensión consiste de corchetes rodeando una expresión seguida de la declaración for y luego cero o más
 declaraciones for o if. El resultado será una nueva lista que sale de evaluar la expresión en el contexto de los for o if
 que le siguen. Por ejemplo, esta lista de comprensión combina los elementos de dos listas si no son iguales:
 >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
 [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
 y es equivalente a:
 >>> combs = []
 >>> for x in [1,2,3]:
 ...     for y in [3,1,4]:
 ...         if x != y:
 ...             combs.append((x, y))
 ...
 >>> combs
 [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
 Notá como el orden de los for y if es el mismo en ambos pedacitos de código.
 Si la expresión es una tupla (como el (x, y) en el ejemplo anterior), debe estar entre paréntesis.
 >>> vec = [-4, -2, 0, 2, 4]
 >>> # crear una nueva lista con los valores duplicados
 28
>>> [x * 2 for x in vec]
 [-8, -4, 0, 4, 8]
 >>> # filtrar la lista para excluir números negativos
 >>> [x for x in vec if x >= 0]
 [0, 2, 4]
 >>> # aplica una función a todos los elementos
 >>> [abs(x) for x in vec]
 [4, 2, 0, 2, 4]
 >>> # llama un método a cada elemento
 >>> frutafresca = ['  banana', '  mora de Logan ', 'maracuya  ']
 >>> [arma.strip() for arma in frutafresca]
 ['banana', 'mora de Logan', 'maracuya']
 >>> # crea una lista de tuplas de dos como (número, cuadrado)
 >>> [(x, x ** 2) for x in range(6)]
 [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
 >>> # la tupla debe estar entre paréntesis, sino es un error
 >>> [x, x ** 2 for x in range(6)]
 Traceback (most recent call last):
 ...
    [x, x ** 2 for x in range(6)]
                 ^
 SyntaxError: invalid syntax
 >>> # aplanar una lista usando comprensión de listas con dos 'for'
 >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
 >>> [num for elem in vec for num in elem]
 [1, 2, 3, 4, 5, 6, 7, 8, 9]
 Las comprensiones de listas pueden contener expresiones complejas y funciones anidadas:
 >>> from math import pi
 >>> [str(round(pi, i)) for i in range(1, 6)]
 ['3.1', '3.14', '3.142', '3.1416', '3.14159']
 Listas por comprensión anidadas
 La expresión inicial de una comprensión de listas puede ser cualquier expresión arbitraria, incluyendo otra comprensión de
 listas.
 Considerá el siguiente ejemplo de una matriz de 3x4 implementada como una lista de tres listas de largo 4:
 >>> matriz = [
 ...     [1, 2, 3, 4],
 ...     [5, 6, 7, 8],
 ...     [9, 10, 11, 12],
 ... ]
 La siguiente comprensión de lista transpondrá las filas y columnas:
 >>> [[fila[i] for fila in matriz] for i in range(4)]
 [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
 Como vimos en la sección anterior, la lista de comprensión anidada se evalua en el contexto del for que lo sigue, por lo que
 este ejemplo equivale a:
 >>> transpuesta = []
 >>> for i in range(4):
 ...     transpuesta.append([fila[i] for fila in matriz])
 ...
 >>> transpuesta
 [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
 29
el cual, a la vez, es lo mismo que:
 >>> transpuesta = []
 >>> for i in range(4):
 ...     # las siguientes 3 lineas hacen la comprensión de listas anidada
 ...     fila_transpuesta = []
 ...     for fila in matriz:
 ...         fila_transpuesta.append(fila[i])
 ...     transpuesta.append(fila_transpuesta)
 ...
 >>> transpuesta
 [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
 En el mundo real, deberías preferir funciones predefinidas a declaraciones con flujo complejo. La función zip() haría un
 buen trabajo para este caso de uso:
 >>> list(zip(*matriz))
 [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
 Ver Desempaquetando una lista de argumentos para detalles en el asterisco de esta línea.
 La instrucción 
Hay una manera de quitar un ítem de una lista dado su índice en lugar de su valor: la instrucción del. Esta es diferente del
 método pop(), el cual devuelve un valor. La instrucción del también puede usarse para quitar secciones de una lista o
 vaciar la lista completa (lo que hacíamos antes asignando una lista vacía a la sección). Por ejemplo:
 >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
 >>> del a[0]
 >>> a
 [1, 66.25, 333, 333, 1234.5]
 >>> del a[2:4]
 >>> a
 [1, 66.25, 1234.5]
 >>> del a[:]
 >>> a
 []
 del puede usarse también para eliminar variables:
 >>> del a
 Hacer referencia al nombre a de aquí en más es un error (al menos hasta que se le asigne otro valor). Veremos otros usos
 para del más adelante.
 Tuplas y secuencias
 Vimos que las listas y cadenas tienen propiedades en común, como el indizado y las operaciones de seccionado. Estas son
 dos ejemplos de datos de tipo secuencia (ver Tipos integrados). Como Python es un lenguaje en evolución, otros datos de
 tipo secuencia pueden agregarse. Existe otro dato de tipo secuencia estándar: la tupla.
 Una tupla consiste de un número de valores separados por comas, por ejemplo:
 >>> t = 12345, 54321, 'hola!'
 >>> t[0]
 12345
 >>> t
 (12345, 54321, 'hola!')
 >>> # Las tuplas pueden anidarse:
 30
... u = t, (1, 2, 3, 4, 5)
 >>> u
 ((12345, 54321, 'hola!'), (1, 2, 3, 4, 5))
 >>> # Las tuplas son inmutables:
 ... t[0] = 88888
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 TypeError: 'tuple' object does not support item assignment
 >>> # pero pueden contener objetos mutables:
 ... v = ([1, 2, 3], [3, 2, 1])
 >>> v
 ([1, 2, 3], [3, 2, 1])
 Como puedes ver, en la salida las tuplas siempre se encierran entre paréntesis, para que las tuplas anidadas puedan
 interpretarse correctamente; pueden ingresarse con o sin paréntesis, aunque a menudo los paréntesis son necesarios de
 todas formas (si la tupla es parte de una expresión más grande). No es posible asignar a los ítems individuales de una tupla,
 pero sin embargo sí se puede crear tuplas que contengan objetos mutables, como las listas.
 A pesar de que las tuplas puedan parecerse a las listas, frecuentemente se utilizan en distintas situaciones y para distintos
 propósitos. Las tuplas son inmutables y normalmente contienen una secuencia heterogénea de elementos que son
 accedidos al desempaquetar (ver más adelante en esta sección) o indizar (o incluso acceder por atributo en el caso de las
 namedtuples). Las listas son mutables, y sus elementos son normalmente homogéneos y se acceden iterando a la lista.
 Un problema particular es la construcción de tuplas que contengan 0 o 1 ítem: la sintaxis presenta algunas peculiaridades
 para estos casos. Las tuplas vacías se construyen mediante un par de paréntesis vacío; una tupla con un ítem se construye
 poniendo una coma a continuación del valor (no alcanza con encerrar un único valor entre paréntesis). Feo, pero efectivo.
 Por ejemplo:
 >>> vacia = ()
 >>> singleton = 'hola',    
>>> len(vacia)
 0
 >>> len(singleton)
 1
 >>> singleton
 ('hola',)
 # <-- notar la coma al final
 La declaración t = 12345, 54321, 'hola!' es un ejemplo de empaquetado de tuplas: los valores 12345, 54321 y
 'hola!' se empaquetan juntos en una tupla.
 La operación inversa también es posible:
 >>> x, y, z = t
 Esto se llama, apropiadamente, desempaquetado de secuencias, y funciona para cualquier secuencia en el lado derecho del
 igual. El desempaquetado de secuencias requiere que la cantidad de variables a la izquierda del signo igual sea el tamaño
 de la secuencia. Notá que la asignación múltiple es en realidad sólo una combinación de empaquetado de tuplas y
 desempaquetado de secuencias.
 Conjuntos
 Python también incluye un tipo de dato para conjuntos. Un conjunto es una colección no ordenada y sin elementos repetidos.
 Los usos básicos de éstos incluyen verificación de pertenencia y eliminación de entradas duplicadas. Los conjuntos también
 soportan operaciones matemáticas como la unión, intersección, diferencia, y diferencia simétrica.
 Las llaves o la función set() pueden usarse para crear conjuntos. Notá que para crear un conjunto vacío tenés que usar
 set(), no {}; esto último crea un diccionario vacío, una estructura de datos que discutiremos en la sección siguiente.
 31
Una pequeña demostración:
 >>> canasta = {'manzana', 'naranja', 'manzana', 'pera', 'naranja', 'banana'}
 >>> print fruta                  # muestra que se removieron los duplicados
 {'pera', 'manzana', 'banana', 'naranja'}
 >>> 'naranja' in canasta         # verificación de pertenencia rápida
 True
 >>> 'yerba' in canasta
 False
 >>> # veamos las operaciones para las letras únicas de dos palabras
 ...
 >>> a = set('abracadabra')
 >>> b = set('alacazam')
 >>> a                                  # letras únicas en a
 {a', 'r', 'b', 'c', 'd'}
 >>> a - b                              # letras en a pero no en b
 {'r', 'b', 'd'}
 >>> a | b                              # letras en a o en b o en ambas
 {'a', 'c', 'b', 'd', 'm', 'l', 'r', 'z'}
 >>> a & b                              # letras en a y en b
 {'a', 'c'}
 >>> a ^ b                              # letras en a o b pero no en ambos
 {'b', 'd', 'm', 'l', 'r', 'z'}
 De forma similar a las comprensiones de listas, está también soportada la comprensión de conjuntos:
 >>> a = {x for x in 'abracadabra' if x not in 'abc'}
 >>> a
 {'r', 'd'}
 Diccionarios
 Otro tipo de dato útil incluído en Python es el diccionario (ver Tipos integrados). Los diccionarios se encuentran a veces en
 otros lenguajes como "memorias asociativas" o "arreglos asociativos". A diferencia de las secuencias, que se indexan
 mediante un rango numérico, los diccionarios se indexan con claves, que pueden ser cualquier tipo inmutable; las cadenas y
 números siempre pueden ser claves. Las tuplas pueden usarse como claves si solamente contienen cadenas, números o
 tuplas; si una tupla contiene cualquier objeto mutable directa o indirectamente, no puede usarse como clave. No podés usar
 listas como claves, ya que las listas pueden modificarse usando asignación por índice, asignación por sección, o métodos
 como append() y extend().
 Lo mejor es pensar en un diccionario como un conjunto no ordenado de pares clave: valor, con el requerimiento de que las
 claves sean únicas (dentro de un diccionario en particular). Un par de llaves crean un diccionario vacío: {}. Colocar una lista
 de pares clave:valor separados por comas entre las llaves añade pares clave:valor iniciales al diccionario; esta también es la
 forma en que los diccionarios se presentan en la salida.
 Las operaciones principales sobre un diccionario son guardar un valor con una clave y extraer ese valor dada la clave.
 También es posible borrar un par clave:valor con del. Si usás una clave que ya está en uso para guardar un valor, el valor
 que estaba asociado con esa clave se pierde. Es un error extraer un valor usando una clave no existente.
 Hacer list(d.keys()) en un diccionario devuelve una lista de todas las claves usadas en el diccionario, en un orden
 arbitrario (si las querés ordenadas, usá en cambio sorted(d.keys()). 6 Para controlar si una clave está en el diccionario,
 usá el in.
 Un pequeño ejemplo de uso de un diccionario:
 >>> tel = {'jack': 4098, 'sape': 4139}
 >>> tel['guido'] = 4127
 >>> tel
 32
{'sape': 4139, 'jack': 4098, 'guido': 4127}
 >>> tel['jack']
 4098
 >>> del tel['sape']
 >>> tel['irv'] = 4127
 >>> tel
 {'jack': 4098, 'irv': 4127, 'guido': 4127}
 >>> list(tel.keys())
 ['irv', 'guido', 'jack']
 >>> sorted(tel.keys())
 ['guido', 'irv', 'jack']
 >>> 'guido' in tel
 True
 >>> 'jack' not in tel
 False
 El constructor dict() crea un diccionario directamente desde secuencias de pares clave-valor:
 >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
 {'sape': 4139, 'jack': 4098, 'guido': 4127}
 Además, las comprensiones de diccionarios se pueden usar para crear diccionarios desde expresiones arbitrarias de clave y
 valor:
 >>> {x: x ** 2 for x in (2, 4, 6)}
 {2: 4, 4: 16, 6: 36}
 Cuando las claves son cadenas simples, a veces resulta más fácil especificar los pares usando argumentos por palabra
 clave:
 >>> dict(sape=4139, guido=4127, jack=4098)
 {'sape': 4139, 'jack': 4098, 'guido': 4127}
 Técnicas de iteración
 Cuando iteramos sobre diccionarios, se pueden obtener al mismo tiempo la clave y su valor correspondiente usando el
 método items().
 >>> caballeros = {'gallahad': 'el puro', 'robin': 'el valiente'}
 >>> for k, v in caballeros.items():
 ...     print(k, v)
 ...
 gallahad el puro
 robin el valiente
 Cuando se itera sobre una secuencia, se puede obtener el índice de posición junto a su valor correspondiente usando la
 función enumerate().
 >>> for i, v in enumerate(['ta', 'te', 'ti']):
 ...     print(i, v)
 ...
 0 ta
 1 te
 2 ti
 Para iterar sobre dos o más secuencias al mismo tiempo, los valores pueden emparejarse con la función zip().
 >>> preguntas = ['nombre', 'objetivo', 'color favorito']
 >>> respuestas = ['lancelot', 'el santo grial', 'azul']
 >>> for p, r in zip(preguntas, respuestas):
 33
...     print('Cual es tu {0}?  {1}.'.format(p, r))
 ...
 Cual es tu nombre?  lancelot.
 Cual es tu objetivo?  el santo grial.
 Cual es tu color favorito?  azul.
 Para iterar sobre una secuencia en orden inverso, se especifica primero la secuencia al derecho y luego se llama a la función
 reversed().
 >>> for i in reversed(range(1, 10, 2)):
 ...     print(i)
 ...
 9
 7
 5
 3
 1
 Para iterar sobre una secuencia ordenada, se utiliza la función sorted() la cual devuelve una nueva lista ordenada dejando
 a la original intacta.
 >>> canasta = ['manzana', 'naranja', 'manzana', 'pera', 'naranja', 'banana']
 >>> for f in sorted(set(canasta)):
 ...     print(f)
 ...
 banana
 manzana
 naranja
 pera
 A veces uno intenta cambiar una lista mientras la está iterando; sin embargo, a menudo es más simple y seguro crear una
 nueva lista:
 >>> datos = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
 >>> datos_filtrados = []
 >>> for valor in datos:
 ...     if not math.isnan(valor):
 ...         datos_filtrados.append(valor)
 ...
 >>> datos_filtrados
 [56.2, 51.7, 55.3, 52.5, 47.8]
 Más acerca de condiciones
 Las condiciones usadas en las instrucciones while e if pueden contener cualquier operador, no sólo comparaciones.
 Los operadores de comparación in y not in verifican si un valor está (o no está) en una secuencia. Los operadores is e
 is not comparan si dos objetos son realmente el mismo objeto; esto es significativo sólo para objetos mutables como las
 listas. Todos los operadores de comparación tienen la misma prioridad, la cual es menor que la de todos los operadores
 numéricos.
 Las comparaciones pueden encadenarse. Por ejemplo, a < b == c verifica si a es menor que b y además si b es igual a c.
 Las comparaciones pueden combinarse mediante los operadores booleanos and y or, y el resultado de una comparación (o
 de cualquier otra expresión booleana) puede negarse con not. Estos tienen prioridades menores que los operadores de
 comparación; entre ellos not tiene la mayor prioridad y or la menor, o sea que A and not B or C equivale a
 (A and (not B)) or C. Como siempre, los paréntesis pueden usarse para expresar la composición deseada.
 34
Los operadores booleanos and y or son los llamados operadores cortocircuito: sus argumentos se evalúan de izquierda a
 derecha, y la evaluación se detiene en el momento en que se determina su resultado. Por ejemplo, si A y C son verdaderas
 pero B es falsa, en A and B and C no se evalúa la expresión C. Cuando se usa como un valor general y no como un
 booleano, el valor devuelto de un operador cortocircuito es el último argumento evaluado.
 Es posible asignar el resultado de una comparación u otra expresión booleana a una variable. Por ejemplo,
 >>> cadena1, cadena2, cadena3 = '', 'Trondheim', 'Paso Hammer'
 >>> non_nulo = cadena1 or cadena2 or cadena3
 >>> non_nulo
 'Trondheim'
 Notá que en Python, a diferencia de C, la asignación no puede ocurrir dentro de expresiones. Los programadores de C
 pueden renegar por esto, pero es algo que evita un tipo de problema común encontrado en programas en C: escribir = en
 una expresión cuando lo que se quiere escribir es ==.
 Comparando secuencias y otros tipos
 Las secuencias pueden compararse con otros objetos del mismo tipo de secuencia. La comparación usa orden lexicográfico:
 primero se comparan los dos primeros ítems, si son diferentes esto ya determina el resultado de la comparación; si son
 iguales, se comparan los siguientes dos ítems, y así sucesivamente hasta llegar al final de alguna de las secuencias. Si dos
 ítems a comparar son ambos secuencias del mismo tipo, la comparación lexicográfica es recursiva. Si todos los ítems de dos
 secuencias resultan iguales, se considera que las secuencias son iguales.
 Si una secuencia es una subsecuencia inicial de la otra, la secuencia más corta es la menor. El orden lexicográfico para
 cadenas de caracteres utiliza el orden de códigos Unicode para caracteres individuales. Algunos ejemplos de
 comparaciones entre secuencias del mismo tipo:
 (1, 2, 3)              
[1, 2, 3]              
< (1, 2, 4)
 < [1, 2, 4]
 'ABC' < 'C' < 'Pascal' < 'Python'
 (1, 2, 3, 4)           
< (1, 2, 4)
 (1, 2)                 
(1, 2, 3)             
< (1, 2, -1)
 == (1.0, 2.0, 3.0)
 (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
 Observá que comparar objetos de diferentes tipos con < o > es legal siempre y cuando los objetas tenga los métodos de
 comparación apropiados. Por ejemplo, los tipos de números mezclados son comparados de acuerdo a su valor numérico, o
 sea 0 es igual a 0.0, etc. Si no es el caso, en lugar de proveer un ordenamiento arbitrario, el intérprete generará una
 excepción TypeError.
 5
 6
 Otros lenguajes pueden devolver el objeto mutado, lo cual permite encadenado de métodos, como
 d->insert("a")->remove("b")->sort();.
 Llamar a d.keys() devolverá un objeto vista de diccionario. Soporta operaciones como prueba de pertenencia e
 iteración, pero sus contenidos dependen del diccionario original -- son sólo una vista.
 35
Módulos
 Si salís del intérprete de Python y entrás de nuevo, las definiciones que hiciste (funciones y variables) se pierden. Por lo
 tanto, si querés escribir un programa más o menos largo, es mejor que uses un editor de texto para preparar la entrada para
 el interprete y ejecutarlo con ese archivo como entrada. Esto es conocido como crear un guión, o script. Si tu programa se
 vuelve más largo, quizás quieras separarlo en distintos archivos para un mantenimiento más fácil. Quizás también quieras
 usar una función útil que escribiste desde distintos programas sin copiar su definición a cada programa.
 Para soportar esto, Python tiene una manera de poner definiciones en un archivo y usarlos en un script o en una instancia
 interactiva del intérprete. Tal archivo es llamado módulo; las definiciones de un módulo pueden ser importadas a otros
 módulos o al módulo principal (la colección de variables a las que tenés acceso en un script ejecutado en el nivel superior y
 en el modo calculadora).
 Un módulo es una archivo conteniendo definiciones y declaraciones de Python. El nombre del archivo es el nombre del
 módulo con el sufijo .py agregado. Dentro de un módulo, el nombre del mismo (como una cadena) está disponible en el valor
 de la variable global __name__. Por ejemplo, usá tu editor de textos favorito para crear un archivo llamado fibo.py en el
 directorio actual, con el siguiente contenido:
 # módulo de números Fibonacci
 def fib(n):    # escribe la serie Fibonacci hasta n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
     print()
 def fib2(n):   # devuelve la serie Fibonacci hasta n
    resultado = []
    a, b = 0, 1
    while b < n:
        resultado.append(b)
        a, b = b, a+b
    return resultado
 Ahora entrá al intérprete de Python e importá este módulo con la siguiente orden:
 >>> import fibo
 Esto no mete los nombres de las funciones definidas en fibo directamente en el espacio de nombres actual; sólo mete ahí
 el nombre del módulo, fibo. Usando el nombre del módulo podés acceder a las funciones:
 >>> fibo.fib(1000)
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
 >>> fibo.fib2(100)
 [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
 >>> fibo.__name__
 'fibo'
 Si pensás usar la función frecuentemente, podés asignarla a un nombre local:
 36
>>> fib = fibo.fib
 >>> fib(500)
 1 1 2 3 5 8 13 21 34 55 89 144 233 377
 Más sobre los módulos
 Un módulo puede contener tanto declaraciones ejecutables como definiciones de funciones. Estas declaraciones están
 pensadas para inicializar el módulo. Se ejecutan solamente la primera vez que el módulo se encuentra en una sentencia
 import. 7 (Son también ejecutados si el archivo es ejecutado como un script).
 Cada módulo tiene su propio espacio de nombres, el que es usado como espacio de nombres global por todas las funciones
 definidas en el módulo. Por lo tanto, el autor de un módulo puede usar variables globales en el módulo sin preocuparse
 acerca de conflictos con una variable global del usuario. Por otro lado, si sabés lo que estás haciendo podés tocar las
 variables globales de un módulo con la misma notación usada para referirte a sus funciones, nombremodulo.nombreitem.
 Los módulos pueden importar otros módulos. Es costumbre pero no obligatorio el ubicar todas las declaraciones import al
 principio del módulo (o script, para el caso). Los nombres de los módulos importados se ubican en el espacio de nombres
 global del módulo que hace la importación.
 Hay una variante de la declaración import que importa los nombres de un módulo directamente al espacio de nombres del
 módulo que hace la importación. Por ejemplo:
 >>> from fibo import fib, fib2
 >>> fib(500)
 1 1 2 3 5 8 13 21 34 55 89 144 233 377
 Esto no introduce en el espacio de nombres local el nombre del módulo desde el cual se está importando (entonces, en el
 ejemplo, fibo no se define).
 Hay incluso una variante para importar todos los nombres que un módulo define:
 >>> from fibo import *
 >>> fib(500)
 1 1 2 3 5 8 13 21 34 55 89 144 233 377
 Esto importa todos los nombres excepto aquellos que comienzan con un subrayado (_). La mayoría de las veces los
 programadores de Python no usan esto ya que introduce un conjunto de nombres en el intérprete, posiblemente
 escondiendo cosas que ya estaban definidas.
 Notá que en general la práctica de importar * de un módulo o paquete está muy mal vista, ya que frecuentemente genera un
 código poco legible. Sin embargo, está bien usarlo para ahorrar tecleo en sesiones interactivas.
 Nota
 Por razones de eficiencia, cada módulo se importa una vez por sesión del intérprete. Por lo tanto, si modificás los
 módulos, tenés que reiniciar el intérprete -- o, si es sólo un módulo que querés probar interactivamente, usá
 imp.reload(), por ejemplo import importlib; importlib.reload(modulename).
 Ejecutando módulos como scripts
 Cuando ejecutás un módulo de Python con
 python fibo.py <argumentos>
 ...el código en el módulo será ejecutado, tal como si lo hubieses importado, pero con __name__ con el valor de
 "__main__". Eso significa que agregando este código al final de tu módulo:
 37
if __name__ == "__main__":
 import sys
 fib(int(sys.argv[1]))
 ...podés hacer que el archivo sea utilizable tanto como script, como módulo importable, porque el código que analiza la linea
 de órdenes sólo se ejecuta si el módulo es ejecutado como archivo principal:
 $ python fibo.py 50
 1 1 2 3 5 8 13 21 34
 Si el módulo se importa, ese código no se ejecuta:
 >>> import fibo
 >>>
 Esto es frecuentemente usado para proveer al módulo una interfaz de usuario conveniente, o para propósitos de prueba
 (ejecutar el módulo como un script ejecuta el juego de pruebas).
 El camino de búsqueda de los módulos
 Cuando se importa un módulo llamado spam, el intérprete busca primero por un módulo con ese nombre que esté integrado
 en el intérprete. Si no lo encuentra, entonces busca un archivo llamado spam.py en una lista de directorios especificada por la
 variable sys.path. sys.path se inicializa con las siguientes ubicaciones:
 • el directorio conteniendo el script (o el directorio actual cuando no se especifica un archivo).
 •
 PYTHONPATH (una lista de nombres de directorios, con la misma sintaxis que la variable de entorno PATH.
 • el directorio default de la instalación.
 Nota
 En sistemas de archivos que soportan enlaces simbólicos, el directorio conteniendo el script de entrada es calculado
 después de que el enlace simbólico sea seguido. En otras palabras, el directorio conteniendo el enlace simbólico no es
 agregado al módulo de busca del path.
 Luego de la inicialización, los programas Python pueden modificar sys.path. El directorio que contiene el script que se está
 ejecutando se ubica al principio de la búsqueda, adelante de la biblioteca estándar. Esto significa que se cargarán scripts en
 ese directorio en lugar de módulos de la biblioteca estándar con el mismo nombre. Esto es un error a menos que se esté
 reemplazando intencionalmente. Mirá la sección Módulos estándar para más información.
 Archivos "compilados" de Python
 Para acelerar la carga de módulos, Python cachea las versiones compiladas de cada módulo en el directorio __pycache__
 bajo el nombre module.version.pyc dónde la versión codifica el formato del archivo compilado; generalmente contiene el
 número de version de Python. Por ejemplo, en CPython release 3.3 la version compilada de spam.py sería cacheada como
 __pycache__/spam.cpython-33.pyc. Este convensión de nombre permite compilar módulos desde diferentes releases
 y versiones de Python para coexistir.
 Python chequea la fecha de modificación de la fuente contra la versión compilada para evr si esta es obsoleta y necesita ser
 recompilada. Esto es un proceso completamente automático. También, los módulos compilados son independientes de la
 plataforma, así que la misma librería puede ser compartida a través de sistemas con diferentes arquitecturas.
 Python no chequea el caché en dos circuntancias. Primero, siempre recompila y no graba el resultado del módulo que es
 cargado directamente desde la línea de comando. Segundo, no chequea el caché si no hay módulo fuente.
 Algunos consejos para expertos:
 38
•Podés usar la -O o -OO en el comando de Python para reducir el tamaño de los módulos compilados. La -O quita
 assert statements, la --O quita ambos, assert statements y cadenas de caracteres __doc__. Debido a que algunos
 programas se basan en que estos estén disponibles, deberías usar esta opción únicamente si sabés lo que estás
 haciendo. Los módulos "optimizados" tienen una etiqueta opt- y son normalmente más pequeños. Releases futuras
 quizás cambien los efectos de la optimización.
 •Un programa no corre más rápido cuando se lee de un archivo .pyc que cuando se lee del .py; lo único que es más
 rápido en los archivos .pyc es la velocidad con que se cargan.
 •Hay más detalles de este proceso, incluyendo un diagrama de flujo de la toma de decisiones, en la PEP 3147.
 •El módulo compilleall puede crear archivos .pyc para todos los módulos en un directorio.
 Módulos estándar
 Python viene con una biblioteca de módulos estándar, descrita en un documento separado, la Referencia de la Biblioteca de
 Python (de aquí en más, "Referencia de la Biblioteca"). Algunos módulos se integran en el intérprete; estos proveen acceso
 a operaciones que no son parte del núcleo del lenguaje pero que sin embargo están integrados, tanto por eficiencia como
 para proveer acceso a primitivas del sistema operativo, como llamadas al sistema. El conjunto de tales módulos es una
 opción de configuración el cual también depende de la plataforma subyacente. Por ejemplo, el módulo winreg sólo se
 provee en sistemas Windows. Un módulo en particular merece algo de atención: sys, el que está integrado en todos los
 intérpretes de Python. Las variables sys.ps1 y sys.ps2 definen las cadenas usadas como cursores primarios y
 secundarios:
 >>> import sys
 >>> sys.ps1
 '>>> '
 >>> sys.ps2
 '... '
 >>> sys.ps1 = 'C> '
 C> print('Yuck!')
 Yuck!
 C>
 Estas dos variables están solamente definidas si el intérprete está en modo interactivo.
 La variable sys.path es una lista de cadenas que determinan el camino de búsqueda del intérprete para los módulos. Se
 inicializa por omisión a un camino tomado de la variable de entorno PYTHONPATH, o a un valor predefinido en el intérprete si
 PYTHONPATH no está configurada. Lo podés modificar usando las operaciones estándar de listas:
 >>> import sys
 >>> sys.path.append('/ufs/guido/lib/python')
 La función 
La función integrada dir() se usa para encontrar qué nombres define un módulo. Devuelve una lista ordenada de cadenas:
 >>> import fibo, sys
 >>> dir(fibo)
 ['__name__', 'fib', 'fib2']
 >>> dir(sys)  # doctest: +NORMALIZE_WHITESPACE
 ['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
 '__package__', '__stderr__', '__stdin__', '__stdout__',
 '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
 '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
 'call_tracing', 'callstats', 'copyright', 'displayhook',
 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
 39
 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
 'thread_info', 'version', 'version_info', 'warnoptions']
 Sin argumentos, dir() lista los nombres que tenés actualmente definidos:
 >>> a = [1, 2, 3, 4, 5]
 >>> import fibo
 >>> fib = fibo.fib
 >>> dir()
 ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
 Notá que lista todos los tipos de nombres: variables, módulos, funciones, etc.
 dir() no lista los nombres de las funciones y variables integradas. Si querés una lista de esos, están definidos en el módulo
 estándar builtins:
 >>> import builtins
 >>> dir(builtins)  # doctest: +NORMALIZE_WHITESPACE
 ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError',
 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
 '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
 'zip']
 40
Paquetes
 Los paquetes son una manera de estructurar los espacios de nombres de Python usando "nombres de módulos con puntos".
 Por ejemplo, el nombre de módulo A.B designa un submódulo llamado B en un paquete llamado A. Tal como el uso de
 módulos evita que los autores de diferentes módulos tengan que preocuparse de los respectivos nombres de variables
 globales, el uso de nombres de módulos con puntos evita que los autores de paquetes de muchos módulos, como NumPy o
 la Biblioteca de Imágenes de Python (Python Imaging Library, o PIL), tengan que preocuparse de los respectivos nombres de
 módulos.
 Suponete que querés designar una colección de módulos (un "paquete") para el manejo uniforme de archivos y datos de
 sonidos. Hay diferentes formatos de archivos de sonido (normalmente reconocidos por su extensión, por ejemplo: .wav, .aiff,
 .au), por lo que tenés que crear y mantener una colección siempre creciente de módulos para la conversión entre los distintos
 formatos de archivos. Hay muchas operaciones diferentes que quizás quieras ejecutar en los datos de sonido (como
 mezclarlos, añadir eco, aplicar una función ecualizadora, crear un efecto estéreo artificial), por lo que ademas estarás
 escribiendo una lista sin fin de módulos para realizar estas operaciones. Aquí hay una posible estructura para tu paquete
 (expresados en términos de un sistema jerárquico de archivos):
 sound/                          Paquete superior
      __init__.py               Inicializa el paquete de sonido
      formats/                  Subpaquete para conversiones de formato
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpaquete para efectos de sonido
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpaquete para filtros
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
 Al importar el paquete, Python busca a través de los directorios en sys.path, buscando el subdirectorio del paquete.
 Los archivos __init__.py se necesitan para hacer que Python trate los directorios como que contienen paquetes; esto se hace
 para prevenir directorios con un nombre común, como string, de esconder sin intención a módulos válidos que se suceden
 luego en el camino de búsqueda de módulos. En el caso más simple, __init__.py puede ser solamente un archivo vacío, pero
 también puede ejecutar código de inicialización para el paquete o configurar la variable __all__, descrita luego.
 Los usuarios del paquete pueden importar módulos individuales del mismo, por ejemplo:
 import sound.effects.echo
 Esto carga el submódulo sound.effects.echo. Debe hacerse referencia al mismo con el nombre completo.
 sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
 Otra alternativa para importar el submódulos es:
 from sound.effects import echo
 41
Esto también carga el submódulo echo, lo deja disponible sin su prefijo de paquete, por lo que puede usarse así:
 echo.echofilter(input, output, delay=0.7, atten=4)
 Otra variación más es importar la función o variable deseadas directamente:
 from sound.effects.echo import echofilter
 De nuevo, esto carga el submódulo echo, pero deja directamente disponible a la función echofilter():
 echofilter(input, output, delay=0.7, atten=4)
 Notá que al usar from package import item el ítem puede ser tanto un submódulo (o subpaquete) del paquete, o algún
 otro nombre definido en el paquete, como una función, clase, o variable. La declaración import primero verifica si el ítem
 está definido en el paquete; si no, asume que es un módulo y trata de cargarlo. Si no lo puede encontrar, se genera una
 excepción ImportError.
 Por otro lado, cuando se usa la sintaxis como import item.subitem.subsubitem, cada ítem excepto el último debe ser
 un paquete; el mismo puede ser un módulo o un paquete pero no puede ser una clase, función o variable definida en el ítem
 previo.
 Importando * desde un paquete
 Ahora, ¿qué sucede cuando el usuario escribe from sound.effects import *? Idealmente, uno esperaría que esto de
 alguna manera vaya al sistema de archivos, encuentre cuales submódulos están presentes en el paquete, y los importe a
 todos. Esto puede tardar mucho y el importar sub-módulos puede tener efectos secundarios no deseados que sólo deberían
 ocurrir cuando se importe explícitamente el sub-módulo.
 La única solución es que el autor del paquete provea un índice explícito del paquete. La declaración import usa la siguiente
 convención: si el código del __init__.py de un paquete define una lista llamada __all__, se toma como la lista de los
 nombres de módulos que deberían ser importados cuando se hace from package import *. Es tarea del autor del
 paquete mantener actualizada esta lista cuando se libera una nueva versión del paquete. Los autores de paquetes podrían
 decidir no soportarlo, si no ven un uso para importar * en sus paquetes. Por ejemplo, el archivo sound/effects/__init__.py podría
 contener el siguiente código:
 __all__ = ["echo", "surround", "reverse"]
 Esto significaría que from sound.effects import * importaría esos tres submódulos del paquete sound.
 Si no se define __all__, la declaración from sound.effects import * no importa todos los submódulos del paquete
 sound.effects al espacio de nombres actual; sólo se asegura que se haya importado el paquete sound.effects
 (posiblemente ejecutando algún código de inicialización que haya en __init__.py) y luego importa aquellos nombres que estén
 definidos en el paquete. Esto incluye cualquier nombre definido (y submódulos explícitamente cargados) por __init__.py.
 También incluye cualquier submódulo del paquete que pudiera haber sido explícitamente cargado por declaraciones import
 previas. Considerá este código:
 import sound.effects.echo
 import sound.effects.surround
 from sound.effects import *
 En este ejemplo, los módulos echo y surround se importan en el espacio de nombre actual porque están definidos en el
 paquete sound.effects cuando se ejecuta la declaración from...import. (Esto también funciona cuando se define
 __all__).
 A pesar de que ciertos módulos están diseñados para exportar solo nombres que siguen ciertos patrones cuando usás
 import *, también se considera una mala práctica en código de producción.
 42
Recordá que no está mal usar from paquete import submodulo_especifico! De hecho, esta notación se
 recomienda a menos que el módulo que estás importando necesite usar submódulos con el mismo nombre desde otros
 paquetes.
 Referencias internas en paquetes
 Cuando se estructuran los paquetes en subpaquetes (como en el ejemplo sound), podés usar import absolutos para
 referirte a submódulos de paquetes hermanos. Por ejemplo, si el módulo sound.filters.vocoder necesita usar el
 módulo echo en el paquete sound.effects, puede hacer from sound.effects import echo.
 También podés escribir import relativos con la forma from module import name. Estos imports usan puntos adelante
 para indicar los paquetes actual o padres involucrados en el import relativo. En el ejemplo surround, podrías hacer:
 from . import echo
 from .. import formats
 from ..filters import equalizer
 Notá que los imports relativos se basan en el nombre del módulo actual. Ya que el nombre del módulo principal es siempre
 "__main__", los módulos pensados para usarse como módulo principal de una aplicación Python siempre deberían usar
 import absolutos.
 Paquetes en múltiples directorios
 Los paquetes soportan un atributo especial más, __path__. Este se inicializa, antes de que el código en ese archivo se
 ejecute, a una lista que contiene el nombre del directorio donde está el paquete. Esta variable puede modificarse, afectando
 búsquedas futuras de módulos y subpaquetes contenidos en el paquete.
 Aunque esta característica no se necesita frecuentemente, puede usarse para extender el conjunto de módulos que se
 encuentran en el paquete.
 7
 De hecho las definiciones de función son también 'declaraciones' que se 'ejecutan'; la ejecución de una definición
 de función a nivel de módulo mete el nombre de la función en el espacio de nombres global.
 43
44

Entrada y salida
 Hay diferentes métodos de presentar la salida de un programa; los datos pueden ser impresos de una forma legible por
 humanos, o escritos a un archivo para uso futuro. Este capítulo discutirá algunas de las posibilidades.
 Formateo elegante de la salida
 Hasta ahora encontramos dos maneras de escribir valores: declaraciones de expresión y la función print(). (Una tercer
 manera es usando el método write() de los objetos tipo archivo; el archivo de salida estándar puede referenciarse como
 sys.stdout. Mirá la Referencia de la Biblioteca para más información sobre esto.)
 Frecuentemente querrás más control sobre el formateo de tu salida que simplemente imprimir valores separados por
 espacios. Hay dos maneras de formatear tu salida; la primera es hacer todo el manejo de las cadenas vos mismo: usando
 rebanado de cadenas y operaciones de concatenado podés crear cualquier forma que puedas imaginar. El tipo string
 contiene algunos métodos útiles para emparejar cadenas a un determinado ancho; estas las discutiremos en breve. La otra
 forma es usar formatted string literals o el método str.format().
 El módulo string contiene una clase string.Template que ofrece otra forma de sustituir valores en las cadenas.
 Nos queda una pregunta, por supuesto: ¿cómo convertís valores a cadenas? Afortunadamente, Python tiene maneras de
 convertir cualquier valor a una cadena: pasalos a las funciones repr() o str().
 La función str() devuelve representaciones de los valores que son bastante legibles por humanos, mientras que repr()
 genera representaciones que pueden ser leídas por el el intérprete (o forzarían un SyntaxError si no hay sintáxis
 equivalente). Para objetos que no tienen una representación en particular para consumo humano, str() devolverá el mismo
 valor que repr(). Muchos valores, como números o estructuras como listas y diccionarios, tienen la misma representación
 usando cualquiera de las dos funciones. Las cadenas, en particular, tienen dos representaciones distintas.
 Algunos ejemplos:
 >>> s = 'Hola mundo.'
 >>> str(s)
 'Hola mundo.'
 >>> repr(s)
 "'Hola mundo.'"
 >>> str(1 / 7)
 '0.142857142857'
 >>> x = 10 * 3.25
 >>> y = 200 * 200
 >>> s = 'El valor de x es ' + repr(x) + ', y es ' + repr(y) + '...'
 >>> print(s)
 El valor de x es 32.5, y es 40000...
 >>> # El repr() de una cadena agrega apóstrofos y barras invertidas
 ... hola = 'hola mundo\n'
 >>> holas = repr(hola)
 >>> print(holas)
 'hola mundo\n'
 >>> # El argumento de repr() puede ser cualquier objeto Python:
 ... repr((x, y, ('carne', 'huevos')))
 "(32.5, 40000, ('carne', 'huevos'))"
 Acá hay dos maneras de escribir una tabla de cuadrados y cubos:
 46
>>> for x in range(1, 11):
 ...     print(repr(x).rjust(2), repr(x * x).rjust(3), end=' ')
 ...     # notar el uso de 'end' en la linea anterior
 ...     print(repr(x * x * x).rjust(4))
 ...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
 10 100 1000
 >>> for x in range(1,11):
 ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x * x, x * x * x))
 ...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
 10 100 1000
 (Notar que en el primer ejemplo, un espacio entre cada columna fue agregado por la manera en que print() trabaja:
 siempre agrega espacios entre sus argumentos)
 Este ejemplo muestra el método str.rjust() de los objetos cadena, el cual ordena una cadena a la derecha en un campo
 del ancho dado llenándolo con espacios a la izquierda. Hay métodos similares str.ljust() y str.center(). Estos
 métodos no escriben nada, sólo devuelven una nueva cadena. Si la cadena de entrada es demasiado larga, no la truncan,
 sino la devuelven intacta; esto te romperá la alineación de tus columnas pero es normalmente mejor que la alternativa, que
 te estaría mintiendo sobre el valor. (Si realmente querés que se recorte, siempre podés agregarle una operación de
 rebanado, como en x.ljust(n)[:n].)
 Hay otro método, str.zfill(), el cual rellena una cadena numérica a la izquierda con ceros. Entiende signos positivos y
 negativos:
 >>> '12'.zfill(5)
 '00012'
 >>> '-3.14'.zfill(7)
 '-003.14'
 >>> '3.14159265359'.zfill(5)
 '3.14159265359'
 El uso básico del método str.format() es como esto:
 >>> print('Somos los {} quienes decimos "{}!"'.format('caballeros', 'Nop'))
 Somos los caballeros quienes decimos "Nop!"
 Las llaves y caracteres dentro de las mismas (llamados campos de formato) son reemplazadas con los objetos pasados en
 el método str.format(). Un número en las llaves se refiere a la posición del objeto pasado en el método.
 47
>>> print('{0} y {1}'.format('carne', 'huevos'))
 carne y huevos
 >>> print('{1} y {0}'.format('carne', 'huevos'))
 huevos y carne
 Si se usan argumentos nombrados en el método str.format(), sus valores serán referidos usando el nombre del
 argumento.
 >>> print('Esta {comida} es {adjetivo}.'.format(
 ...       comida='carne', adjetivo='espantosa'))
 Esta carne es espantosa.
 Se pueden combinar arbitrariamente argumentos posicionales y nombrados:
 >>> print('La historia de {0}, {1}, y {otro}.'.format('Bill', 'Manfred',
 ...                                                   otro='Georg'))
 La historia de Bill, Manfred, y Georg.
 Se pueden usar '!a' (aplica apply()), '!s' (aplica str()) y '!r' (aplica repr()) para convertir el valor antes de que
 se formatee.
 >>> contents = 'anguilas'
 >>> print('Mi aerodeslizador esta lleno de {}.'.format(contents))
 Mi aerodeslizador esta lleno de anguilas.
 >>> print('My hovercraft is full of {!r}.'.format(contents))
 Mi aerodeslizador esta lleno de 'anguilas'.
 Un ': y especificador de formato opcionales pueden ir luego del nombre del campo. Esto aumenta el control sobre cómo el
 valor es formateado. El siguiente ejemplo redondea Pi a tres lugares luego del punto decimal.
 >>> import math
 >>> print('El valor de PI es aproximadamente {0:.3f}.'.format(math.pi))
 El valor de PI es aproximadamente 3.142.
 Pasando un entero luego del ':' causará que que el campo sea de un mínimo número de caracteres de ancho. Esto es útil
 para hacer tablas lindas.
 >>> tabla = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
 >>> for nombre, telefono in tabla.items():
 ...     print('{0:10} ==> {1:10d}'.format(nombre, telefono))
 ...
 Dcab       ==>       7678
 Jack       ==>       4098
 Sjoerd     ==>       4127
 Si tenés una cadena de formateo realmente larga que no querés separar, podría ser bueno que puedas hacer referencia a
 las variables a ser formateadas por el nombre en vez de la posición. Esto puede hacerse simplemente pasando el diccionario
 y usando corchetes '[]' para acceder a las claves
 >>> tabla = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
 >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
 ...       'Dcab: {0[Dcab]:d}'.format(tabla))
 Jack: 4098; Sjoerd: 4127; Dcab: 8637678
 Esto se podría también hacer pasando la tabla como argumentos nombrados con la notación '**'.
 >>> tabla = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
 >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; '
          'Dcab: {Dcab:d}'.format(**tabla))
 Jack: 4098; Sjoerd: 4127; Dcab: 8637678
 48
Esto es particularmente útil en combinación con la función integrada vars(), que devuelve un diccionario conteniendo todas
 las variables locales.
 Para una completa descripción del formateo de cadenas con str.format(), mirá en Tipos integrados.
 Viejo formateo de cadenas
 El operador % también puede usarse para formateo de cadenas. Interpreta el argumento de la izquierda con el estilo de
 formateo de sprintf() para ser aplicado al argumento de la derecha, y devuelve la cadena resultante de esta operación
 de formateo. Por ejemplo:
 >>> import math
 >>> print('El valor de PI es aproximadamente %5.3f.' % math.pi)
 El valor de PI es aproximadamente 3.142.
 Podés encontrar más información en la sección Tipos integrados.
 Leyendo y escribiendo archivos
 La función open() devuelve un objeto archivo, y se usa normalmente con dos argumentos:
 open(nombre_de_archivo, modo).
 >>> f = open('archivodetrabajo', 'w')
 >>> print(f)
 <_io.TextIOWrapper name='archivodetrabajo' mode='w' encoding='UTF-8'>
 El primer argumento es una cadena conteniendo el nombre de archivo. El segundo argumento es otra cadena conteniendo
 unos pocos caracteres que describen la forma en que el archivo será usado. El modo puede ser 'r' cuando el archivo será
 solamente leído, 'w' para sólo escribirlo (un archivo existente con el mismo nombre será borrado), y 'a' abre el archivo
 para agregarle información; cualquier dato escrito al archivo será automáticamente agregado al final. 'r+' abre el archivo
 tanto para leerlo como para escribirlo. El argumento modo es opcional; si se omite se asume 'r'.
 Normalmente los archivos se abren en modo texto, lo que significa que podés leer y escribir cadenas del y al archivo, las
 cuales se codifican utilizando un código específico. Si el código no es especificado, el valor predeterminado depende de la
 plataforma. Si se agrega b al modo el archivo se abre en modo binario: ahora los datos se leen y escriben en forma de
 objetos bytes. Se debería usar este modo para todos los archivos que no contengan texto.
 Cuando se lee en modo texto, por defecto se convierten los fines de lineas que son específicos a las plataformas (\n en
 Unix, \r\n en Windows) a solamente \n. Cuando se escribe en modo texto, por defecto se convierten los \n a los finales de
 linea específicos de la plataforma. Este cambio automático está bien para archivos de texto, pero corrompería datos binarios
 como los de archivos JPEG o EXE. Asegurate de usar modo binario cuando leas y escribas tales archivos.
 Es una buena práctica usar la declaración with cuando manejamos objetos archivo. Tiene la ventaja que el archivo es
 cerrado apropiadamente luego de que el bloque termina, incluso si se generó una excepción. También es mucho más corto
 que escribir los equivalentes bloques try-finally
 >>> with open('archivodetrabajo') as f:
 ...     
datos_leidos = f.read()
 >>> f.closed
 True
 Si no estuvieses usando el bloque with, entonces deberías llamar f.close() para cerrar el archivo e inmediatamente
 liberar cualquier recurso del sistema usado por este. Si no cierras explícitamente el archivo, el «garbage collector» de Python
 eventualmente destruirá el objeto y cerrará el archivo por vos, pero el archivo puede estar abierto por un tiempo. Otro riesgo
 es que diferentes implementaciones de Python harán esta limpieza en diferentes momentos.
 Después de que un objeto de archivo es cerrado, ya sea por with o llamando a f.close(), intentar volver a utilizarlo
 fallará automáticamente:
 49
>>> f.close()
 >>> f.read()
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 ValueError: I/O operation on closed file
 Métodos de los objetos Archivo
 El resto de los ejemplos en esta sección asumirán que ya se creó un objeto archivo llamado f.
 Para leer el contenido de una archivo llamá a f.read(cantidad), el cual lee alguna cantidad de datos y los devuelve
 como una cadena de (en modo texto) o un objeto de bytes (en modo binario). cantidad es un argumento numérico opcional.
 Cuando se omite cantidad o es negativo, el contenido entero del archivo será leido y devuelto; es tu problema si el archivo es
 el doble de grande que la memoria de tu máquina. De otra manera, a lo sumo una cantidad de bytes son leídos y devueltos.
 Si se alcanzó el fin del archivo, f.read() devolverá una cadena vacía ("").
 >>> f.read()
 'Este es el archivo entero.\n'
 >>> f.read()
 ''
 f.readline() lee una sola linea del archivo; el caracter de fin de linea (\n) se deja al final de la cadena, y sólo se omite en
 la última linea del archivo si el mismo no termina en un fin de linea. Esto hace que el valor de retorno no sea ambiguo; si
 f.readline() devuelve una cadena vacía, es que se alcanzó el fin del archivo, mientras que una linea en blanco es
 representada por '\n', una cadena conteniendo sólo un único fin de linea.
 >>> f.readline()
 'Esta es la primer linea del archivo.\n'
 >>> f.readline()
 'Segunda linea del archivo\n'
 >>> f.readline()
 ''
 Para leer líneas de un archivo, podés iterar sobre el objeto archivo. Esto es eficiente en memoria, rápido, y conduce a un
 código más simple:
 >>> for linea in f:
 ...     print(linea, end='')
 Esta es la primer linea del archivo
 Segunda linea del archivo
 Si querés leer todas las líneas de un archivo en una lista también podés usar list(f) o f.readlines().
 f.write(cadena) escribe el contenido de la cadena al archivo, devolviendo la cantidad de caracteres escritos.
 >>> f.write('Esto es una prueba\n')
 19
 Otros tipos de objetos necesitan serconvertidos -- tanto a una cadena (en modo texto) o a un objeto de bytes (en modo
 binario) -- antes de escribirlos:
 >>> valor = ('la respuesta', 42)
 >>> s = str(valor)  # Convierte la tupla a string
 >>> f.write(s)
 18
 f.tell() devuelve un entero que indica la posición actual en el archivo representada como número de bytes desde el
 comienzo del archivo en modo binario y un número opaco en modo texto.
 50
Para cambiar la posición del objeto archivo, usá f.seek(desplazamiento, desde_donde). La posición es calculada
 agregando el desplazamiento a un punto de referencia; el punto de referencia se selecciona del argumento desde_donde.
 Un valor desde_donde de 0 mide desde el comienzo del archivo, 1 usa la posición actual del archivo, y 2 usa el fin del
 archivo como punto de referencia. desde_donde puede omitirse, el default es 0, usando el comienzo del archivo como punto
 de referencia.
 >>> f = open('archivodetrabajo', 'rb+')
 >>> f.write(b'0123456789abcdef')
 >>> f.seek(5)     
# Va al sexto byte en el archivo
 5
 >>> f.read(1)
 b'5'
 >>> f.seek(-3, 2) # Va al tercer byte antes del final
 13
 >>> f.read(1)
 b'd'
 En los archivos de texto (aquellos que se abrieron sin una b en el modo), se permiten solamente desplazamientos con seek
 relativos al comienzo (con la excepción de ir justo al final con seek(0, 2)) y los únicos valores de desplazamiento válidos
 son aquellos retornados por f.tell(), o cero. Cualquier otro valor de desplazamiento produce un comportamiento
 indefinido.
 Los objetos archivo tienen algunos métodos más, como isatty() y truncate() que son usados menos frecuentemente;
 consultá la Referencia de la Biblioteca para una guía completa sobre los objetos archivo.
 Guardar datos estructurados con 
Las cadenas pueden facilmente escribirse y leerse de un archivo. Los números toman algo más de esfuerzo, ya que el
 método read() sólo devuelve cadenas, que tendrán que ser pasadas a una función como int(), que toma una cadena
 como '123' y devuelve su valor numérico 123. Sin embargo, cuando querés grabar tipos de datos más complejos como
 listas, diccionarios, o instancias de clases, las cosas se ponen más complicadas.
 En lugar de tener a los usuarios constantemente escribiendo y debugueando código para grabar tipos de datos complicados,
 Python te permite usar formato intercambiable de datos popular llamado JSON (JavaScript Object Notation). El módulo
 estandar llamado json puede tomar datos de Python con una jerarquía, y convertirlo a representaciones de cadena de
 caracteres; este proceso es llamado serializing. Reconstruir los datos desde la representación de cadena de caracteres es
 llamado deserializing. Entre serialización y deserialización, la cadena de caracteres representando el objeto quizás haya sido
 guardado en un archivo o datos, o enviado a una máquina distante por una conexión de red.
 Nota
 El formato JSON es comunmente usado por aplicaciones modernas para permitir intercambiar datos. Muchos
 programadores están familiarizados con este, lo que lo hace una buena elección por su interoperatividad.
 Si tienes un objeto x, puedes ver su representación JSON con una simple línea de código:
 >>> import json
 >>> json.dumps([1, 'simple', 'lista'])
 '[1, "simple", "lista"]'
 json.dump(x, f)
 Otra variante de la función dumps(), llamada dump(), simplemente serializa el objeto a un archivo de texto. Así que, si f es
 un objeto archivo de texto abierto para escritura, podemos hacer:
 Para decodificar un objeto nuevamente, si f es un objeto archivo de texto que fue abierto para lectura:
 51
x = json.load(x, f)
 La simple técnica de serialización puede manejar listas y diccionarios, pero serializar instancias de clases arbitrarias en
 JSON requiere un poco de esfuerzo extra. La referencia del módulo json contiene una explicación de esto.
 Ver también
 pickle - el módulo pickle
 Contrariamente a JSON, pickle es un protocolo que permite la serialización de arbitrariamente objetos complejos de
 Python. Por lo tanto, este es específico de Python y no puede ser usado para comunicarse con aplicaciones escritas en
 otros lenguajes. Es inseguro por defecto: deserializar datos que fueron serializados con pickle desde fuentes inseguras
 puede ejecutar código arbitrario, si los datos fueron interceptados por un atacante experto.
 52
Errores y excepciones
 Hasta ahora los mensajes de error no habían sido más que mencionados, pero si probaste los ejemplos probablemente
 hayas visto algunos. Hay (al menos) dos tipos diferentes de errores: errores de sintaxis y excepciones.
 Errores de sintaxis
 Los errores de sintaxis, también conocidos como errores de interpretación, son quizás el tipo de queja más común que tenés
 cuando todavía estás aprendiendo Python:
 >>> while True print('Hola mundo')
  File "<stdin>", line 1
 while True print('Hola mundo')
 ^
 SyntaxError: invalid syntax
 El intérprete repite la línea culpable y muestra una pequeña 'flecha' que apunta al primer lugar donde se detectó el error.
 Este es causado por (o al menos detectado en) el símbolo que precede a la flecha: en el ejemplo, el error se detecta en la
 función print(), ya que faltan dos puntos (':') antes del mismo. Se muestran el nombre del archivo y el número de línea
 para que sepas dónde mirar en caso de que la entrada venga de un programa.
 Excepciones
 Incluso si la declaración o expresión es sintácticamente correcta, puede generar un error cuando se intenta ejecutarla. Los
 errores detectados durante la ejecución se llaman excepciones, y no son incondicionalmente fatales: pronto aprenderás
 cómo manejarlos en los programas en Python. Sin embargo, la mayoría de las excepciones no son manejadas por los
 programas, y resultan en mensajes de error como los mostrados aquí:
 >>> 10 * (1/0)
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 ZeroDivisionError: division by zero
 >>> 4 + spam*3
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 NameError: name 'spam' is not defined
 >>> '2' + 2
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 TypeError: Can't convert 'int' object to str implicitly
 La última línea de los mensajes de error indica qué sucedió. Las excepciones vienen de distintos tipos, y el tipo se imprime
 como parte del mensaje: los tipos en el ejemplo son: ZeroDivisionError, NameError y TypeError. La cadena
 mostrada como tipo de la excepción es el nombre de la excepción predefinida que ocurrió. Esto es verdad para todas las
 excepciones predefinidas del intérprete, pero no necesita ser verdad para excepciones definidas por el usuario (aunque es
 una convención útil). Los nombres de las excepciones estándar son identificadores incorporados al intérprete (no son
 palabras clave reservadas).
 El resto de la línea provee un detalle basado en el tipo de la excepción y qué la causó.
 53
La parte anterior del mensaje de error muestra el contexto donde la excepción sucedió, en la forma de un trazado del error
 listando líneas fuente; sin embargo, no mostrará líneas leídas desde la entrada estándar.
 Excepciones integradas lista las excepciones predefinidas y sus significados.
 Manejando excepciones
 Es posible escribir programas que manejen determinadas excepciones. Mirá el siguiente ejemplo, que le pide al usuario una
 entrada hasta que ingrese un entero válido, pero permite al usuario interrumpir el programa (usando Control-C o lo que sea
 que el sistema operativo soporte); notá que una interrupción generada por el usuario se señaliza generando la excepción
 KeyboardInterrupt.
 >>> while True:
 ...     try:
 ...         x = int(input("Por favor ingrese un número: "))
 ...         break
 ...     except ValueError:
 ...         print("Oops! No era válido. Intente nuevamente...")
 ...
 La declaración try funciona de la siguiente manera:
 •Primero, se ejecuta el bloque try (el código entre las declaración try y except).
 •Si no ocurre ninguna excepción, el bloque except se saltea y termina la ejecución de la declaración try.
 •Si ocurre una excepción durante la ejecución del bloque try, el resto del bloque se saltea. Luego, si su tipo coincide con
 la excepción nombrada luego de la palabra reservada except, se ejecuta el bloque except, y la ejecución continúa
 luego de la declaración try.
 •Si ocurre una excepción que no coincide con la excepción nombrada en el except, esta se pasa a declaraciones try
 de más afuera; si no se encuentra nada que la maneje, es una excepción no manejada, y la ejecución se frena con un
 mensaje como los mostrados arriba.
 Una declaración try puede tener más de un except, para especificar manejadores para distintas excepciones. A lo sumo
 un manejador será ejecutado. Sólo se manejan excepciones que ocurren en el correspondiente try, no en otros
 manejadores del mismo try. Un except puede nombrar múltiples excepciones usando paréntesis, por ejemplo:
 ... except (RuntimeError, TypeError, NameError):
 ...     pass
 Una clase en una clausula except es compatible con una excepción si la misma esta en la misma clase o una clase base de
 la misma (pero no de la otra manera --- una clausula except listando una clase derivada no es compatible con una clase
 base). Por ejemplo, el siguiente código imprimirá B, C, D, en ese orden:
 class B(Exception):
    pass
 class C(B):
    pass
 class D(C):
    pass
 for cls in [B, C, D]:
    try:
        raise cls()
    except D:
        print("D")
    except C:
 54
        print("C")
    except B:
        print("B")
 Notese que si las clausulas de except estuvieran invertidas (con except B primero), habría impreso B, B, B --- la primera
 clausula de except coincidente es usada.
 El último except puede omitir nombrar qué excepción captura, para servir como comodín. Usá esto con extremo cuidado,
 ya que de esta manera es fácil ocultar un error real de programación. También puede usarse para mostrar un mensaje de
 error y luego re-generar la excepción (permitiéndole al que llama, manejar también la excepción):
 import sys
 try:
    f = open('miarchivo.txt')
    s = f.readline()
    i = int(s.strip())
 except OSError as err:
    print("Error OS: {0}".format(err))
 except ValueError:
    print("No pude convertir el dato a un entero.")
 except:
    print("Error inesperado:", sys.exc_info()[0])
    raise
 Las declaraciones try ... except tienen un bloque else opcional, el cual, cuando está presente, debe seguir a los except.
 Es útil para aquel código que debe ejecutarse si el bloque try no genera una excepción. Por ejemplo:
 for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('no pude abrir', arg)
    else:
        print(arg, 'tiene', len(f.readlines()), 'lineas')
        f.close()
 El uso de else es mejor que agregar código adicional en el try porque evita capturar accidentalmente una excepción que
 no fue generada por el código que está protegido por la declaración try ... except.
 Cuando ocurre una excepción, puede tener un valor asociado, también conocido como el argumento de la excepción. La
 presencia y el tipo de argumento depende del tipo de excepción.
 El except puede especificar una variable luego del nombre de excepción. La variable se vincula a una instancia de
 excepción con los argumentos almacenados en instance.args. Por conveniencia, la instancia de excepción define
 __str__() para que se pueda mostrar los argumentos directamente, sin necesidad de hacer referencia a .args. También
 se puede instanciar la excepción primero, antes de generarla, y agregarle los atributos que se desee:
 >>> try:
 ...    raise Exception('carne', 'huevos')
 ... except Exception as inst:
 ...    print(type(inst))    # la instancia de excepción
 ...    print(inst.args)     # argumentos guardados en .args
 ...    print(inst)          # __str__ permite imprimir args directamente,
 ...                         # pero puede ser cambiado en subclases de la exc
 ...    x, y = inst          # desempacar argumentos
 ...    print('x =', x)
 ...    print('y =', y)
 ...
 <class 'Exception'>
 55
('carne', 'huevos')
 ('carne', 'huevos')
 x = carne
 y = huevos
 Si una excepción tiene argumentos, estos se imprimen como la última parte (el 'detalle') del mensaje para las excepciones
 que no están manejadas.
 Los manejadores de excepciones no manejan solamente las excepciones que ocurren en el bloque try, también manejan las
 excepciones que ocurren dentro de las funciones que se llaman (inclusive indirectamente) dentro del bloque try. Por ejemplo:
 >>> def esto_falla():
 ...     x = 1/0
 ...
 >>> try:
 ...     esto_falla()
 ... except ZeroDivisionError as err:
 ...     print('Manejando error en tiempo de ejecución:', err)
 ...
 Manejando error en tiempo de ejecución: division by zero
 Levantando excepciones
 La declaración raise permite al programador forzar a que ocurra una excepción específica. Por ejemplo:
 >>> raise NameError('Hola')
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
 NameError: Hola
 El único argumento a raise indica la excepción a generarse. Tiene que ser o una instancia de excepción, o una clase de
 excepción (una clase que hereda de Exception). Si se pasa una clase de excepción, la misma sera instanciada
 implicitamente llamandoa su constructor sin argumentos:
 raise ValueError  # atajo para 'raise ValueError()'
 Si necesitás determinar cuando una excepción fue lanzada pero no querés manejarla, una forma simplificada de la
 instrucción raise te permite relanzarla:
 >>> try:
 ...     raise NameError('Hola')
 ... except NameError:
 ...     print('Voló una excepción!')
 ...     raise
 ...
 Voló una excepción!
 Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
 NameError: Hola
 Excepciones definidas por el usuario
 Los programas pueden nombrar sus propias excepciones creando una nueva clase excepción (mirá Clases para más
 información sobre las clases de Python). Las excepciones, típicamente, deberán derivar de la clase Exception, directa o
 indirectamente.
 Las clases de Excepciones pueden ser definidas de la misma forma que cualquier otra clase, pero usualmente se mantienen
 simples, a menudo solo ofreciendo un número de atributos con información sobre el error que leerán los manejadores de la
 56
excepción. Al crear un módulo que puede lanzar varios errores distintos, una práctica común es crear una clase base para
 excepciones definidas en ese módulo y extenderla para crear clases excepciones específicas para distintas condiciones de
 error:
 class Error(Exception):
    """Clase base para excepciones en el módulo."""
    pass
 class EntradaError(Error):
    """Excepción lanzada por errores en las entradas.
    Atributos:
        expresion -- expresión de entrada en la que ocurre el error
        mensaje -- explicación del error
    """
    def __init__(self, expresion, mensaje):
        self.expresion = expresion
        self.mensaje = mensaje
 class TransicionError(Error):
    """Lanzada cuando una operacion intenta una transicion de estado no
    permitida.
    Atributos:
        previo -- estado al principio de la transición
        siguiente -- nuevo estado intentado
        mensaje -- explicación de por qué la transición no está permitida
    """
    def __init__(self, previo, siguiente, mensaje):
        self.previo = previo
        self.siguiente = siguiente
        self.mensaje = mensaje
 La mayoría de las excepciones son definidas con nombres que terminan en "Error", similares a los nombres de las
 excepciones estándar.
 Muchos módulos estándar definen sus propias excepciones para reportar errores que pueden ocurrir en funciones propias.
 Se puede encontrar más información sobre clases en el capítulo Clases.
 Definiendo acciones de limpieza
 La declaración try tiene otra cláusula opcional que intenta definir acciones de limpieza que deben ser ejecutadas bajo
 ciertas circunstancias. Por ejemplo:
 >>> try:
 ...     raise KeyboardInterrupt
 ... finally:
 ...     print('Chau, mundo!')
 ...
 Chau, mundo!
 KeyboardInterrupt
 Traceback (most recent call last):
  File "<stdin>", line 2, in ?
 Una cláusula finally siempre es ejecutada antes de salir de la declaración try, ya sea que una excepción haya ocurrido o no.
 Cuando ocurre una excepción en la cláusula try y no fue manejada por una cláusula except (o ocurrió en una cláusula
 except o else), es relanzada luego de que se ejecuta la cláusula finally. El finally es también ejecutado "a la salida"
 57
cuando cualquier otra cláusula de la declaración try es dejada via break, continue or return. Un ejemplo más
 complicado:
 >>> def dividir(x, y):
 ...     try:
 ...         result = x / y
 ...     except ZeroDivisionError:
 ...         print("¡división por cero!")
 ...     else:
 ...         print("el resultado es", result)
 ...     finally:
 ...         print("ejecutando la clausula finally")
 ...
 >>> dividir(2, 1)
 el resultado es 2.0
 ejecutando la clausula finally
 >>> dividir(2, 0)
 ¡división por cero!
 ejecutando la clausula finally
 >>> divide("2", "1")
 ejecutando la clausula finally
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in divide
 TypeError: unsupported operand type(s) for /: 'str' and 'str'
 Como podés ver, la cláusula finally es ejecutada siempre. La excepción TypeError lanzada al dividir dos cadenas de
 texto no es manejado por la cláusula except y por lo tanto es relanzada luego de que se ejecuta la cláusula finally.
 En aplicaciones reales, la cláusula finally es útil para liberar recursos externos (como archivos o conexiones de red), sin
 importar si el uso del recurso fue exitoso.
 Acciones predefinidas de limpieza
 Algunos objetos definen acciones de limpieza estándar que llevar a cabo cuando el objeto no es más necesitado,
 independientemente de que las operaciones sobre el objeto hayan sido exitosas o no. Mirá el siguiente ejemplo, que intenta
 abrir un archivo e imprimir su contenido en la pantalla.:
 for linea in open("miarchivo.txt"):
    print(linea, end="")
 El problema con este código es que deja el archivo abierto por un periodo de tiempo indeterminado luego de que esta parte
 termine de ejecutarse. Esto no es un problema en scripts simples, pero puede ser un problema en aplicaciones más grandes.
 La declaración with permite que objetos como archivos sean usados de una forma que asegure que siempre se los libera
 rápido y en forma correcta.:
 with open("miarchivo.txt") as f:
    for linea in f:
        print(linea, end="")
 Luego de que la declaración sea ejecutada, el archivo f siempre es cerrado, incluso si se encuentra un problema al procesar
 las líneas. Objetos que, como los archivos, provean acciones de limpieza predefinidas lo indicarán en su documentación.
 58
Clases
 Las clases proveen una forma de empaquetar datos y funcionalidad juntos. Al crear una nueva clase, se crea un nuevo tipo
 de objeto, permitiendo crear nuevas instancias de ese tipo. Cada instancia de clase puede tener atributos adjuntos para
 mantener su estado. Las instancias de clase también pueden tener métodos (definidos por su clase) para modificar su
 estado.
 Comparado con otros lenguajes de programación, el mecanismo de clases de Python agrega clases con un mínimo de
 nuevas sintaxis y semánticas. Es una mezcla de los mecanismos de clases encontrados en C++ y Modula-3. Las clases de
 Python proveen todas las características normales de la Programación Orientada a Objetos: el mecanismo de la herencia de
 clases permite múltiples clases base, una clase derivada puede sobre escribir cualquier método de su(s) clase(s) base, y un
 método puede llamar al método de la clase base con el mismo nombre. Los objetos pueden tener una cantidad arbitraria de
 datos de cualquier tipo. Igual que con los módulos, las clases participan de la naturaleza dinámica de Python: se crean en
 tiempo de ejecución, y pueden modificarse luego de la creación.
 En terminología de C++, normalmente los miembros de las clases (incluyendo los miembros de datos), son públicos (excepto
 ver abajo Variables privadas), y todas las funciones miembro son virtuales. Como en Modula-3, no hay atajos para hacer
 referencia a los miembros del objeto desde sus métodos: la función método se declara con un primer argumento explícito
 que representa al objeto, el cual se provee implícitamente por la llamada. Como en Smalltalk, las clases mismas son objetos.
 Esto provee una semántica para importar y renombrar. A diferencia de C++ y Modula-3, los tipos de datos integrados pueden
 usarse como clases base para que el usuario los extienda. También, como en C++ pero a diferencia de Modula-3, la mayoría
 de los operadores integrados con sintaxis especial (operadores aritméticos, de subíndice, etc.) pueden ser redefinidos por
 instancias de la clase.
 (Sin haber una terminología universalmente aceptada sobre clases, haré uso ocasional de términos de Smalltalk y C++.
 Usaría términos de Modula-3, ya que su semántica orientada a objetos es más cercana a Python que C++, pero no espero
 que muchos lectores hayan escuchado hablar de él).
 Unas palabras sobre nombres y objetos
 Los objetos tienen individualidad, y múltiples nombres (en muchos ámbitos) pueden vincularse al mismo objeto. Esto se
 conoce como aliasing en otros lenguajes. Normalmente no se aprecia esto a primera vista en Python, y puede ignorarse sin
 problemas cuando se maneja tipos básicos inmutables (números, cadenas, tuplas). Sin embargo, el aliasing, o renombrado,
 tiene un efecto posiblemente sorpresivo sobre la semántica de código Python que involucra objetos mutables como listas,
 diccionarios, y la mayoría de otros tipos. Esto se usa normalmente para beneficio del programa, ya que los renombres
 funcionan como punteros en algunos aspectos. Por ejemplo, pasar un objeto es barato ya que la implementación solamente
 pasa el puntero; y si una función modifica el objeto que fue pasado, el que la llama verá el cambio; esto elimina la necesidad
 de tener dos formas diferentes de pasar argumentos, como en Pascal.
 Ámbitos y espacios de nombres en Python
 Antes de ver clases, primero debo decirte algo acerca de las reglas de ámbito de Python. Las definiciones de clases hacen
 unos lindos trucos con los espacios de nombres, y necesitás saber cómo funcionan los alcances y espacios de nombres
 para entender por completo cómo es la cosa. De paso, los conocimientos en este tema son útiles para cualquier
 programador Python avanzado.
 Comencemos con unas definiciones.
 59
Un espacio de nombres es una relación de nombres a objetos. Muchos espacios de nombres están implementados en este
 momento como diccionarios de Python, pero eso no se nota para nada (excepto por el desempeño), y puede cambiar en el
 futuro. Como ejemplos de espacios de nombres tenés: el conjunto de nombres incluidos (conteniendo funciones como
 abs(), y los nombres de excepciones integradas); los nombres globales en un módulo; y los nombres locales en la
 invocación a una función. Lo que es importante saber de los espacios de nombres es que no hay relación en absoluto entre
 los nombres de espacios de nombres distintos; por ejemplo, dos módulos diferentes pueden tener definidos los dos una
 función maximizar sin confusión; los usuarios de los módulos deben usar el nombre del módulo como prefijo.
 Por cierto, yo uso la palabra atributo para cualquier cosa después de un punto; por ejemplo, en la expresión z.real, real
 es un atributo del objeto z. Estrictamente hablando, las referencias a nombres en módulos son referencias a atributos: en la
 expresión modulo.funcion, modulo es un objeto módulo y funcion es un atributo de éste. En este caso hay una relación
 directa entre los atributos del módulo y los nombres globales definidos en el módulo: ¡están compartiendo el mismo espacio
 de nombres! 8
 Los atributos pueden ser de sólo lectura, o de escritura. En el último caso es posible la asignación a atributos. Los atributos
 de módulo pueden escribirse: modulo.la_respuesta = 42. Los atributos de escritura se pueden borrar también con la
 declaración del. Por ejemplo, del modulo.la_respuesta va a eliminar el atributo la_respuesta del objeto con
 nombre modulo.
 Los espacios de nombres se crean en diferentes momentos y con diferentes tiempos de vida. El espacio de nombres que
 contiene los nombres incluidos se crea cuando se inicia el intérprete, y nunca se borra. El espacio de nombres global de un
 módulo se crea cuando se lee la definición de un módulo; normalmente, los espacios de nombres de módulos también duran
 hasta que el intérprete finaliza. Las instrucciones ejecutadas en el nivel de llamadas superior del intérprete, ya sea desde un
 script o interactivamente, se consideran parte del módulo llamado __main__, por lo tanto tienen su propio espacio de
 nombres global. (Los nombres incluidos en realidad también viven en un módulo; este se llama builtins.)
 El espacio de nombres local a una función se crea cuando la función es llamada, y se elimina cuando la función retorna o
 lanza una excepción que no se maneje dentro de la función. (Podríamos decir que lo que pasa en realidad es que ese
 espacio de nombres se "olvida".) Por supuesto, las llamadas recursivas tienen cada una su propio espacio de nombres local.
 Un ámbito es una región textual de un programa en Python donde un espacio de nombres es accesible directamente.
 "Accesible directamente" significa que una referencia sin calificar a un nombre intenta encontrar dicho nombre dentro del
 espacio de nombres.
 Aunque los alcances se determinan estáticamente, se usan dinámicamente. En cualquier momento durante la ejecución hay
 por lo menos cuatro alcances anidados cuyos espacios de nombres son directamente accesibles:
 • el ámbito interno, donde se busca primero, contiene los nombres locales
 • los espacios de nombres de las funciones anexas, en las cuales se busca empezando por el ámbito adjunto más
 cercano, contiene los nombres no locales pero también los no globales
 • el ámbito anteúltimo contiene los nombres globales del módulo actual
 • el ámbito exterior (donde se busca al final) es el espacio de nombres que contiene los nombres incluidos
 Si un nombre se declara como global, entonces todas las referencias y asignaciones al mismo van directo al ámbito
 intermedio que contiene los nombres globales del módulo. Para reasignar nombres encontrados afuera del ámbito más
 interno, se puede usar la declaración nonlocal; si no se declara nonlocal, esas variables serán de sólo lectura (un intento
 de escribir a esas variables simplemente crea una nueva variable local en el ámbito interno, dejando intacta la variable
 externa del mismo nombre).
 Habitualmente, el ámbito local referencia los nombres locales de la función actual. Fuera de una función, el ámbito local
 referencia al mismo espacio de nombres que el ámbito global: el espacio de nombres del módulo. Las definiciones de clases
 crean un espacio de nombres más en el ámbito local.
 Es importante notar que los alcances se determinan textualmente: el ámbito global de una función definida en un módulo es
 el espacio de nombres de ese módulo, no importa desde dónde o con qué alias se llame a la función. Por otro lado, la
 búsqueda de nombres se hace dinámicamente, en tiempo de ejecución; sin embargo, la definición del lenguaje está
 60
evolucionando a hacer resolución de nombres estáticamente, en tiempo de "compilación", ¡así que no te confíes de la
 resolución de nombres dinámica! (De hecho, las variables locales ya se determinan estáticamente.)
 Una peculiaridad especial de Python es que, si no hay una declaración global o nonlocal en efecto, las asignaciones a
 nombres siempre van al ámbito interno. Las asignaciones no copian datos, solamente asocian nombres a objetos. Lo mismo
 cuando se borra: la declaración del x quita la asociación de x del espacio de nombres referenciado por el ámbito local. De
 hecho, todas las operaciones que introducen nuevos nombres usan el ámbito local: en particular, las instrucciones import y
 las definiciones de funciones asocian el módulo o nombre de la función al espacio de nombres en el ámbito local.
 La declaración global puede usarse para indicar que ciertas variables viven en el ámbito global y deberían reasignarse allí;
 la declaración nonlocal indica que ciertas variables viven en un ámbito encerrado y deberían reasignarse allí.
 Ejémplo de ámbitos y espacios de nombre
 Este es un ejemplo que muestra como hacer referencia a distintos ámbitos y espacios de nombres, y cómo las declaraciones
 global y nonlocal afectan la asignación de variables:
 def prueba_ambitos():
    def hacer_local():
        algo = "algo local"
    def hacer_nonlocal():
        nonlocal algo
        algo = "algo no local"
    def hacer_global():
        global algo
        algo = "algo global"
    algo = "algo de prueba"
    hacer_local()
    print("Luego de la asignación local:", algo)
    hacer_nonlocal()
    print("Luego de la asignación no local:", algo)
    hacer_global()
    print("Luego de la asignación global:", algo)
 prueba_ambitos()
 print("In global scope:", algo)
 El resultado del código ejemplo es:
 Luego de la asignación local: algo de prueba
 Luego de la asignación no local: algo no local
 Luego de la asignación global: algo no local
 En el ámbito global: algo global
 Notá como la asignación local (que es el comportamiento normal) no cambió la vinculación de algo de prueba_ambitos. La
 asignación nonlocal cambió la vinculación de algo de prueba_ambitos, y la asignación global cambió la vinculación a
 nivel de módulo.
 También podés ver que no había vinculación para algo antes de la asignación global.
 Un primer vistazo a las clases
 Las clases introducen un poquito de sintaxis nueva, tres nuevos tipos de objetos y algo de semántica nueva.
 Sintaxis de definición de clases
 La forma más sencilla de definición de una clase se ve así:
 61
class Clase:
 <declaración-1>
 .
 .
 .
 <declaración-N>
 Las definiciones de clases, al igual que las definiciones de funciones (instrucciones def) deben ejecutarse antes de que
 tengan efecto alguno. (Es concebible poner una definición de clase dentro de una rama de un if, o dentro de una función.)
 En la práctica, las declaraciones dentro de una clase son definiciones de funciones, pero otras declaraciones son permitidas,
 y a veces resultan útiles; veremos esto más adelante. Las definiciones de funciones dentro de una clase normalmente
 tienen una lista de argumentos peculiar, dictada por las convenciones de invocación de métodos; a esto también lo veremos
 más adelante.
 Cuando se ingresa una definición de clase, se crea un nuevo espacio de nombres, el cual se usa como ámbito local; por lo
 tanto, todas las asignaciones a variables locales van a este nuevo espacio de nombres. En particular, las definiciones de
 funciones asocian el nombre de las funciones nuevas allí.
 Cuando una definición de clase se finaliza normalmente se crea un objeto clase. Básicamente, este objeto envuelve los
 contenidos del espacio de nombres creado por la definición de la clase; aprenderemos más acerca de los objetos clase en la
 sección siguiente. El ámbito local original (el que tenía efecto justo antes de que ingrese la definición de la clase) es
 restablecido, y el objeto clase se asocia allí al nombre que se le puso a la clase en el encabezado de su definición (Clase en
 el ejemplo).
 Objetos clase
 Los objetos clase soportan dos tipos de operaciones: hacer referencia a atributos e instanciación.
 Para hacer referencia a atributos se usa la sintaxis estándar de todas las referencias a atributos en Python:
 objeto.nombre. Los nombres de atributo válidos son todos los nombres que estaban en el espacio de nombres de la clase
 cuando ésta se creó. Por lo tanto, si la definición de la clase es así:
 class MiClase:
 """Simple clase de ejemplo"""
 i = 12345
 def f(self):
 return 'hola mundo'
 ...entonces MiClase.i y MiClase.f son referencias de atributos válidas, que devuelven un entero y un objeto función
 respectivamente. Los atributos de clase también pueden ser asignados, o sea que podés cambiar el valor de MiClase.i
 mediante asignación. __doc__ también es un atributo válido, que devuelve la documentación asociada a la clase:
 "Simple clase de ejemplo".
 x = MiClase()
 La instanciación de clases usa la notación de funciones. Hacé de cuenta que el objeto de clase es una función sin
 parámetros que devuelve una nueva instancia de la clase. Por ejemplo (para la clase de más arriba):
 ...crea una nueva instancia de la clase y asigna este objeto a la variable local x.
 La operación de instanciación ("llamar" a un objeto clase) crea un objeto vacío. Muchas clases necesitan crear objetos con
 instancias en un estado inicial particular. Por lo tanto una clase puede definir un método especial llamado __init__(), de
 esta forma:
 def __init__(self):
 self.datos = []
 62
x = MiClase()
 Cuando una clase define un método __init__(), la instanciación de la clase automáticamente invoca a __init__() para
 la instancia recién creada. Entonces, en este ejemplo, una instancia nueva e inicializada se puede obtener haciendo:
 Por supuesto, el método __init__() puede tener argumentos para mayor flexibilidad. En ese caso, los argumentos que se
 pasen al operador de instanciación de la clase van a parar al método __init__(). Por ejemplo,
 >>> class Complejo:
 ...     
def __init__(self, partereal, parteimaginaria):
 ...         
...         
self.r = partereal
 self.i = parteimaginaria
 ...
 >>> x = Complejo(3.0, -4.5)
 >>> x.r, x.i
 (3.0, -4.5)
 Objetos instancia
 Ahora, ¿Qué podemos hacer con los objetos instancia? La única operación que es entendida por los objetos instancia es la
 referencia de atributos. Hay dos tipos de nombres de atributos válidos, atributos de datos y métodos.
 Los atributos de datos se corresponden con las "variables de instancia" en Smalltalk, y con las "variables miembro" en C++.
 Los atributos de datos no necesitan ser declarados; tal como las variables locales son creados la primera vez que se les
 asigna algo. Por ejemplo, si x es la instancia de MiClase creada más arriba, el siguiente pedazo de código va a imprimir el
 valor 16, sin dejar ningún rastro:
 x.contador = 1
 while x.contador < 10:
 x.contador = x.contador * 2
 print(x.contador)
 del x.contador
 El otro tipo de atributo de instancia es el método. Un método es una función que "pertenece a" un objeto. En Python, el
 término método no está limitado a instancias de clase: otros tipos de objetos pueden tener métodos también. Por ejemplo,
 los objetos lista tienen métodos llamados append, insert, remove, sort, y así sucesivamente. Pero, en la siguiente
 explicación, usaremos el término método para referirnos exclusivamente a métodos de objetos instancia de clase, a menos
 que se especifique explícitamente lo contrario.
 Los nombres válidos de métodos de un objeto instancia dependen de su clase. Por definición, todos los atributos de clase
 que son objetos funciones definen métodos correspondientes de sus instancias. Entonces, en nuestro ejemplo, x.f es una
 referencia a un método válido, dado que MiClase.f es una función, pero x.i no lo es, dado que MiClase.i no lo es. Pero
 x.f no es la misma cosa que MiClase.f; es un objeto método, no un objeto función.
 Objetos método
 Generalmente, un método es llamado luego de ser vinculado:
 x.f()
 En el ejemplo MiClase, esto devuelve la cadena 'hola mundo'. Pero no es necesario llamar al método justo en ese
 momento: x.f es un objeto método, y puede ser guardado y llamado más tarde. Por ejemplo:
 xf = x.f
 while True:
 print(xf())
 ...continuará imprimiendo hola mundo hasta el fin de los días.
 63
¿Qué sucede exactamente cuando un método es llamado? Debés haber notado que x.f() fue llamado más arriba sin
 ningún argumento, a pesar de que la definición de función de f() especificaba un argumento. ¿Qué pasó con ese
 argumento? Seguramente Python levanta una excepción cuando una función que requiere un argumento es llamada sin
 ninguno, aún si el argumento no es utilizado...
 De hecho, tal vez hayas adivinado la respuesta: lo que tienen de especial los métodos es que el objeto es pasado como el
 primer argumento de la función. En nuestro ejemplo, la llamada x.f() es exactamente equivalente a MiClase.f(x). En
 general, llamar a un método con una lista de n argumentos es equivalente a llamar a la función correspondiente con una lista
 de argumentos que es creada insertando el objeto del método antes del primer argumento.
 Si aún no comprendés como funcionan los métodos, un vistazo a la implementación puede ayudar a clarificar este tema.
 Cuando se hace referencia un atributo de instancia y no es un atributo de datos, se busca dentro de su clase. Si el nombre
 denota un atributo de clase válido que es un objeto función, se crea un objeto método juntando (punteros a) el objeto
 instancia y el objeto función que ha sido encontrado. Este objeto abstracto creado de esta unión es el objeto método.
 Cuando el objeto método es llamado con una lista de argumentos, una lista de argumentos nueva es construida a partir del
 objeto instancia y la lista de argumentos original, y el objeto función es llamado con esta nueva lista de argumentos.
 Variables de clase y de instancia
 En general, las variables de instancia son para datos únicos de cada instancia y las variables de clase son para atributos y
 métodos compartidos por todas las instancias de la clase:
 class Perro:
    tipo = 'canino'                 # variable de clase compartida por todas las instancias
    def __init__(self, nombre):
        self.nombre = nombre        # variable de instancia única para la instancia
  >>> d = Perro('Fido')
  >>> e = Perro('Buddy')
  >>> d.tipo                    # compartido por todos los perros
  'canino'
  >>> e.tipo                    # compartido por todos los perros
  'canino'
  >>> d.nombre                  # único para d
  'Fido'
  >>> e.nombre                  # único para e
  'Buddy'
 Como se vió en Unas palabras sobre nombres y objetos, los datos compartidos pueden tener efectos inesperados que
 involucren objetos mutables como ser listas y diccionarios. Por ejemplo, la lista trucos en el siguiente código no debería ser
 usada como variable de clase porque una sola lista sería compartida por todos las instancias de Perro:
 class Perro:
    trucos = []        # uso incorrecto de una variable de clase
    def __init__(self, nombre):
        self.nombre = nombre
    def agregar_truco(self, truco):
        self.trucos.append(truco)
  >>> d = Perro('Fido')
  >>> e = Perro('Buddy')
  >>> d.agregar_truco('girar')
  >>> e.agregar_truco('hacerse el muerto')
 64
>>> d.trucos                
# compartidos por todos los perros inesperadamente
 ['girar', 'hacerse el muerto']
 El diseño correcto de esta clase sería usando una variable de instancia:
 class Perro:
 def __init__(self, nombre):
 self.nombre = nombre
 self.trucos = []    
# crea una nueva lista vacía para cada perro
 def agregar_truco(self, truco):
 self.trucos.append(truco)
 >>> d = Perro('Fido')
 >>> e = Perro('Buddy')
 >>> d.agregar_truco('girar')
 >>> e.agregar_truco('hacerse el muerto')
 >>> d.trucos
 ['girar']
 >>> e.trucos
 ['hacerse el muerto']
 Algunas observaciones
 Los atributos de datos tienen preferencia sobre los métodos con el mismo nombre; para evitar conflictos de nombre
 accidentales, que pueden causar errores difíciles de encontrar en programas grandes, es prudente usar algún tipo de
 convención que minimice las posibilidades de dichos conflictos. Algunas convenciones pueden ser poner los nombres de
 métodos con mayúsculas, prefijar los nombres de atributos de datos con una pequeña cadena única (a lo mejor sólo un
 guión bajo), o usar verbos para los métodos y sustantivos para los atributos.
 A los atributos de datos los pueden hacer referencia tanto los métodos como los usuarios ("clientes") ordinarios de un
 objeto. En otras palabras, las clases no se usan para implementar tipos de datos abstractos puros. De hecho, en Python no
 hay nada que haga cumplir el ocultar datos; todo se basa en convención. (Por otro lado, la implementación de Python,
 escrita en C, puede ocultar por completo detalles de implementación y el control de acceso a un objeto si es necesario; esto
 se puede usar en extensiones a Python escritas en C.)
 Los clientes deben usar los atributos de datos con cuidado; éstos pueden romper invariantes que mantienen los métodos si
 pisan los atributos de datos. Observá que los clientes pueden añadir sus propios atributos de datos a una instancia sin
 afectar la validez de sus métodos, siempre y cuando se eviten conflictos de nombres; de nuevo, una convención de
 nombres puede ahorrar un montón de dolores de cabeza.
 No hay un atajo para hacer referencia a atributos de datos (¡u otros métodos!) desde dentro de un método. A mi parecer,
 esto en realidad aumenta la legibilidad de los métodos: no existe posibilidad alguna de confundir variables locales con
 variables de instancia cuando repasamos un método.
 A menudo, el primer argumento de un método se llama self (uno mismo). Esto no es nada más que una convención: el
 nombre self no significa nada en especial para Python. Observá que, sin embargo, si no seguís la convención tu código
 puede resultar menos legible a otros programadores de Python, y puede llegar a pasar que un programa navegador de
 clases pueda escribirse de una manera que dependa de dicha convención.
 Cualquier objeto función que es un atributo de clase define un método para instancias de esa clase. No es necesario que el
 la definición de la función esté textualmente dentro de la definición de la clase: asignando un objeto función a una variable
 local en la clase también está bien. Por ejemplo:
 # Función definida fuera de la clase
 def f1(self, x, y):
 return min(x, x+y)
 65
class C:
 f = f1
 def g(self):
 return 'hola mundo'
 h = g
 Ahora f, g y h son todos atributos de la clase C que hacen referencia a objetos función, y consecuentemente son todos
 métodos de las instancias de C; h siendo exactamente equivalente a g. Fijate que esta práctica normalmente sólo sirve para
 confundir al que lea un programa.
 Los métodos pueden llamar a otros métodos de la instancia usando el argumento self:
 class Bolsa:
 def __init__(self):
 self.datos = []
 def agregar(self, x):
 self.datos.append(x)
 def dobleagregar(self, x):
 self.agregar(x)
 self.agregar(x)
 Los métodos pueden hacer referencia a nombres globales de la misma manera que lo hacen las funciones comunes. El
 ámbito global asociado a un método es el módulo que contiene su definición. (Una clase nunca se usa como un ámbito
 global.) Si bien es raro encontrar una buena razón para usar datos globales en un método, hay muchos usos legítimos del
 ámbito global: por lo menos, las funciones y módulos importados en el ámbito global pueden usarse por los métodos, al
 igual que las funciones y clases definidas en él. Habitualmente, la clase que contiene el método está definida en este ámbito
 global, y en la siguiente sección veremos algunas buenas razones por las que un método querría hacer referencia a su
 propia clase.
 Todo valor es un objeto, y por lo tanto tiene una clase (también llamado su tipo). Ésta se almacena como
 objeto.__class__.
 Herencia
 Por supuesto, una característica del lenguaje no sería digna del nombre "clase" si no soportara herencia. La sintaxis para
 una definición de clase derivada se ve así:
 class ClaseDerivada(ClaseBase):
 <declaración-1>
 .
 .
 .
 <declaración-N>
 El nombre ClaseBase debe estar definido en un ámbito que contenga a la definición de la clase derivada. En el lugar del
 nombre de la clase base se permiten otras expresiones arbitrarias. Esto puede ser útil, por ejemplo, cuando la clase base
 está definida en otro módulo:
 class ClaseDerivada(modulo.ClaseBase):
 La ejecución de una definición de clase derivada procede de la misma forma que una clase base. Cuando el objeto clase se
 construye, se tiene en cuenta a la clase base. Esto se usa para resolver referencias a atributos: si un atributo solicitado no
 se encuentra en la clase, la búsqueda continúa por la clase base. Esta regla se aplica recursivamente si la clase base
 misma deriva de alguna otra clase.
 No hay nada en especial en la instanciación de clases derivadas: ClaseDerivada() crea una nueva instancia de la clase.
 Las referencias a métodos se resuelven de la siguiente manera: se busca el atributo de clase correspondiente,
 66
descendiendo por la cadena de clases base si es necesario, y la referencia al método es válida si se entrega un objeto
 función.
 Las clases derivadas pueden redefinir métodos de su clase base. Como los métodos no tienen privilegios especiales cuando
 llaman a otros métodos del mismo objeto, un método de la clase base que llame a otro método definido en la misma clase
 base puede terminar llamando a un método de la clase derivada que lo haya redefinido. (Para los programadores de C++: en
 Python todos los métodos son en efecto virtuales.)
 Un método redefinido en una clase derivada puede de hecho querer extender en vez de simplemente reemplazar al método
 de la clase base con el mismo nombre. Hay una manera simple de llamar al método de la clase base directamente:
 simplemente llamás a ClaseBase.metodo(self, argumentos). En ocasiones esto es útil para los clientes también.
 (Observá que esto sólo funciona si la clase base es accesible como ClaseBase en el ámbito global.)
 Python tiene dos funciones integradas que funcionan con herencia:
 •
 •
 Usá isinstance() para verificar el tipo de una instancia: isinstance(obj, int) devuelve True solo si
 obj.__class__ es int o alguna clase derivada de int.
 Usá issubclass() para comprobar herencia de clase: issubclass(bool, int) da True ya que bool es una
 subclase de int. Sin embargo, issubclass(float, int) devuelve False porque float no es una subclase de
 int.
 Herencia múltiple
 Python también soporta una forma de herencia múltiple. Una definición de clase con múltiples clases base se ve así:
 class ClaseDerivada(Base1, Base2, Base3):
 <declaración-1>
 .
 .
 .
 <declaración-N>
 Para la mayoría de los propósitos, en los casos más simples, podés pensar en la búsqueda de los atributos heredados de
 clases padres como primero en profundidad, de izquierda a derecha, sin repetir la misma clase cuando está dos veces en la
 jerarquía. Por lo tanto, si un atributo no se encuentra en ClaseDerivada, se busca en Base1, luego (recursivamente) en
 las clases base de Base1, y sólo si no se encuentra allí se lo busca en Base2, y así sucesivamente.
 En realidad es un poco más complejo que eso; el orden de resolución de métodos cambia dinámicamente para soportar las
 llamadas cooperativas a super(). Este enfoque es conocido en otros lenguajes con herencia múltiple como "llámese al
 siguiente método" y es más poderoso que la llamada al superior que se encuentra en lenguajes con sólo herencia simple.
 El ordenamiento dinámico es necesario porque todos los casos de herencia múltiple exhiben una o más relaciones en
 diamante (cuando se puede llegar al menos a una de las clases base por distintos caminos desde la clase de más abajo).
 Por ejemplo, todas las clases heredan de object, por lo tanto cualquier caso de herencia múltiple provee más de un camino
 para llegar a object. Para que las clases base no sean accedidas más de una vez, el algoritmo dinámico hace lineal el
 orden de búsqueda de manera que se preserve el orden de izquierda a derecha especificado en cada clase, que se llame a
 cada clase base sólo una vez, y que sea monótona (lo cual significa que una clase puede tener clases derivadas sin afectar
 el orden de precedencia de sus clases bases). En conjunto, estas propiedades hacen posible diseñar clases confiables y
 extensibles con herencia múltiple. Para más detalles mirá https://www.python.org/download/releases/2.3/mro/.
 Variables privadas
 Las variables "privadas" de instancia, que no pueden accederse excepto desde dentro de un objeto, no existen en Python.
 Sin embargo, hay una convención que se sigue en la mayoría del código Python: un nombre prefijado con un guión bajo (por
 ejemplo, _spam) debería tratarse como una parte no pública de la API (más allá de que sea una función, un método, o un
 dato). Debería considerarse un detalle de implementación y que está sujeto a cambios sin aviso.
 67
Ya que hay un caso de uso válido para los identificadores privados de clase (a saber: colisión de nombres con nombres
 definidos en las subclases), hay un soporte limitado para este mecanismo. Cualquier identificador con la forma __spam (al
 menos dos guiones bajos al principio, como mucho un guión bajo al final) es textualmente reemplazado por
 _nombredeclase__spam, donde nombredeclase es el nombre de clase actual al que se le sacan guiones bajos del
 comienzo (si los tuviera). Se modifica el nombre del identificador sin importar su posición sintáctica, siempre y cuando ocurra
 dentro de la definición de una clase.
 La modificación de nombres es útil para dejar que las subclases sobreescriban los métodos sin romper las llamadas a los
 métodos desde la misma clase. Por ejemplo:
 class Mapeo:
    def __init__(self, iterable):
        self.lista_de_items = []
        self.__actualizar(iterable)
    def actualizar(self, iterable):
        for item in iterable:
            self.lista_de_items.append(item)
    __actualizar = actualizar   # copia privada del actualizar() original
 class SubClaseMapeo(Mapeo):
    def actualizar(self, keys, values):
        # provee una nueva signatura para actualizar()
        # pero no rompe __init__()
        for item in zip(keys, values):
            self.lista_de_items.append(item)
 Hay que aclarar que las reglas de modificación de nombres están diseñadas principalmente para evitar accidentes; es
 posible acceder o modificar una variable que es considerada como privada. Esto hasta puede resultar útil en circunstancias
 especiales, tales como en el depurador.
 Notar que el código pasado a exec o eval() no considera que el nombre de clase de la clase que invoca sea la clase
 actual; esto es similar al efecto de la sentencia global, efecto que es de similar manera restringido a código que es
 compilado en conjunto. La misma restricción aplica a getattr(), setattr() y delattr(), así como cuando se
 referencia a __dict__ directamente.
 Cambalache
 A veces es útil tener un tipo de datos similar al "registro" de Pascal o la "estructura" de C, que sirva para juntar algunos
 pocos ítems con nombre. Una definición de clase vacía funcionará perfecto:
 class Empleado:
    pass
 juan = Empleado()  # Crear un registro de empleado vacío
 # Llenar los campos del registro
 juan.nombre = 'Juan Pistola'
 juan.depto = 'laboratorio de computación'
 juan.salario = 1000
 Algún código Python que espera un tipo abstracto de datos en particular puede frecuentemente recibir en cambio una clase
 que emula los métodos de aquel tipo de datos. Por ejemplo, si tenés una función que formatea algunos datos a partir de un
 objeto archivo, podés definir una clase con métodos read() y readline() que obtengan los datos de alguna cadena en
 memoria intermedia, y pasarlo como argumento.
 68
Los objetos método de instancia tienen atributos también: m.__self__ es el objeto instancia con el método m(), y
 m.__func__ es el objeto función correspondiente al método.
 Iteradores
 Es probable que hayas notado que la mayoría de los objetos contenedores pueden ser recorridos usando una sentencia
 for:
 for elemento in [1, 2, 3]:
    print(elemento)
 for elemento in (1, 2, 3):
    print(elemento)
 for clave in {'uno':1, 'dos':2}:
    print(clave)
 for caracter in "123":
    print(caracter)
 for linea in open("miarchivo.txt"):
    print(linea, end='')
 Este estilo de acceso es limpio, conciso y conveniente. El uso de iteradores está impregnado y unifica a Python. En
 bambalinas, la sentencia for llama a iter() en el objeto contenedor. La función devuelve un objeto iterador que define el
 método __next__() que accede elementos en el contenedor de a uno por vez. Cuando no hay más elementos,
 __next__() levanta una excepción StopIteration que le avisa al bucle del for que hay que terminar. Podés llamar al
 método __next__() usando la función integrada __next__(); este ejemplo muestra como funciona todo esto:
 >>> s = 'abc'
 >>> it = iter(s)
 >>> it
 <iterator object at 0x00A1DB50>
 >>> next(it)
 'a'
 >>> next(it)
 'b'
 >>> next(it)
 'c'
 >>> next(it)
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
 StopIteration
 Habiendo visto la mecánica del protocolo de iteración, es fácil agregar comportamiento de iterador a tus clases. Definí un
 método __iter__() que devuelva un objeto con un método __next__(). Si la clase define __next__(), entonces
 alcanza con que __iter__() devuelva self:
 >>> class Reversa:
 ...     """Iterador para recorrer una secuencia marcha atrás."""
 ...     def __init__(self, datos):
 ...         self.datos = datos
 ...         self.indice = len(datos)
 ...     def __iter__(self):
 ...         return self
 ...     def __next__(self):
 ...         if self.indice == 0:
 ...             raise StopIteration
 ...         self.indice = self.indice - 1
 ...         return self.datos[self.indice]
 ...
 >>> rev = Reversa('spam')
 69
>>> iter(rev)
 <__main__.Reversa object at 0x00A1DB50>
 >>> for char in rev:
 ...     print(char)
 ...
 m
 a
 p
 s
 Generadores
 Los generadores son una simple y poderosa herramienta para crear iteradores. Se escriben como funciones regulares pero
 usan la sentencia yield cuando quieren devolver datos. Cada vez que se llama next() sobre él, el generador continúa
 desde donde dejó (y recuerda todos los valores de datos y cual sentencia fue ejecutada última). Un ejemplo muestra que los
 generadores pueden ser muy fáciles de crear:
 >>> def reversa(datos):
 ...     for indice in range(len(datos)-1, -1, -1):
 ...         yield datos[indice]
 ...
 >>> for letra in reversa('golf'):
 ...     print(letra)
 ...
 f
 l
 o
 g
 Todo lo que puede ser hecho con generadores también puede ser hecho con iteradores basados en clases, como se
 describe en la sección anterior. Lo que hace que los generadores sean tan compactos es que los métodos __iter__() y
 __next__() son creados automáticamente.
 Otra característica clave es que las variables locales y el estado de la ejecución son guardados automáticamente entre
 llamadas. Esto hace que la función sea más fácil de escribir y quede mucho más claro que hacerlo usando variables de
 instancia tales como self.indice y self.datos.
 Además de la creación automática de métodos y el guardar el estado del programa, cuando los generadores terminan
 automáticamente levantan StopIteration. Combinadas, estas características facilitan la creación de iteradores, y hacen
 que no sea más esfuerzo que escribir una función regular.
 Expresiones generadoras
 Algunos generadores simples pueden ser codificados concisamente como expresiones usando una sintaxis similar a las
 listas por comprensión pero con paréntesis en vez de corchetes. Estas expresiones se utilizan en situaciones donde el
 generador es usado inmediatamente por una función que lo contiene. Las expresiones generadoras son más compactas
 pero menos versátiles que definiciones completas de generadores, y tienden a utilizar menos memoria que las listas por
 comprensión equivalentes.
 Ejemplos:
 >>> sum(i*i for i in range(10))                 # suma de cuadrados
 285
 >>> xvec = [10, 20, 30]
 >>> yvec = [7, 5, 3]
 >>> sum(x*y for x,y in zip(xvec, yvec))         # producto escalar
 70
260
 >>> from math import pi, sin
 >>> tabla_de_senos = {x: sin(x*pi/180) for x in range(0, 91)}
 >>> palabras_unicas = set(word  for line in page  for word in line.split())
 >>> mejor_promedio = max((alumno.promedio, alumno.nombre) for alumno in graduados)
 >>> data = 'golf'
 >>> list(data[i] for i in range(len(data) - 1, -1, -1))
 ['f', 'l', 'o', 'g']
 8
 Excepto por un detalle. Los objetos módulo tienen un atributo secreto de solo lectura llamado __dict__ que
 devuelve el diccionario usado para implementar el espacio de nombres del módulo; el nombre __dict__ es un
 atributo, pero no es un nombre global. Obviamente, esto viola la abstracción de la implementación de espacios de
 nombres, y debe ser restringido a cosas tales como depuradores post-mortem.
 71
Pequeño paseo por la Biblioteca 
Estándar
 Interfaz al sistema operativo
 El módulo os provee docenas de funciones para interactuar con el sistema operativo:
 >>> import os
 >>> os.getcwd()      # devuelve el directorio de trabajo actual
 'C:\\Python36'
 >>> os.chdir('/server/accesslogs')   # cambia el directorio de trabajo
 >>> os.system('mkdir today')   # ejecuta el comando 'mkdir' en el sistema
 0
 Asegurate de usar el estilo import os en lugar de from os import *. Esto evitará que os.open() oculte a la función
 integrada open(), que trabaja bastante diferente.
 Las funciones integradas dir() y help() son útiles como ayudas interactivas para trabajar con módulos grandes como os:
 >>> import os
 >>> dir(os)
 <devuelve una lista de todas las funciones del módulo>
 >>> help(os)
 <devuelve un manual creado a partir de las documentaciones del módulo>
 Para tareas diarias de administración de archivos y directorios, el módulo shutil provee una interfaz de más alto nivel que
 es más fácil de usar:
 >>> import shutil
 >>> shutil.copyfile('datos.db', 'archivo.db')
 'archivo.db'
 >>> shutil.move('/build/executables', 'dir_instalac')
 'dir_instalac'
 Comodines de archivos
 El módulo glob provee una función para hacer listas de archivos a partir de búsquedas con comodines en directorios:
 >>> import glob
 >>> glob.glob('*.py')
 ['primes.py', 'random.py', 'quote.py']
 Argumentos de linea de órdenes
 Los programas frecuentemente necesitan procesar argumentos de linea de órdenes. Estos argumentos se almacenan en el
 atributo argv del módulo sys como una lista. Por ejemplo, la siguiente salida resulta de ejecutar
 python demo.py uno dos tres en la línea de órdenes:
 >>> import sys
 >>> print(sys.argv)
 ['demo.py', 'uno', 'dos', 'tres']
 72
El módulo getopt procesa sys.argv usando las convenciones de la función de Unix getopt(). El módulo argparse
 provee un procesamiento más flexible de la linea de órdenes.
 Redirección de la salida de error y finalización del programa
 El módulo sys también tiene atributos para stdin, stdout, y stderr. Este último es útil para emitir mensajes de alerta y error
 para que se vean incluso cuando se haya redireccionado stdout:
 >>> sys.stderr.write('Alerta, archivo de log no encontrado\n')
 Alerta, archivo de log no encontrado
 La forma más directa de terminar un programa es usar sys.exit().
 Coincidencia en patrones de cadenas
 El módulo re provee herramientas de expresiones regulares para un procesamiento avanzado de cadenas. Para
 manipulación y coincidencias complejas, las expresiones regulares ofrecen soluciones concisas y optimizadas:
 >>> import re
 >>> re.findall(r'\bt[a-z]*', 'tres felices tigres comen trigo')
 ['tres', 'tigres', 'trigo']
 >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'gato en el el sombrero')
 'gato en el sombrero'
 Cuando se necesita algo más sencillo solamente, se prefieren los métodos de las cadenas porque son más fáciles de leer y
 depurar.
 >>> 'te para tos'.replace('tos', 'dos')
 'te para dos'
 Matemática
 El módulo math permite el acceso a las funciones de la biblioteca C subyacente para la matemática de punto flotante:
 >>> import math
 >>> math.cos(math.pi / 4)
 0.70710678118654757
 >>> math.log(1024, 2)
 10.0
 El módulo random provee herramientas para realizar selecciones al azar:
 >>> import random
 >>> random.choice(['manzana', 'pera', 'banana'])
 'manzana'
 >>> random.sample(range(100), 10)   # elección sin reemplazo
 [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
 >>> random.random()    # un float al azar
 0.17970987693706186
 >>> random.randrange(6)    # un entero al azar tomado de range(6)
 4
 El módulo statistics calcula propiedades de estadística básica (la media, mediana, varianza, etc) de datos númericos:
 >>> import statistics
 >>> datos = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
 >>> statistics.mean(datos)
 1.6071428571428572
 >>> statistics.median(datos)
 73
1.25
 >>> statistics.variance(datos)
 1.3720238095238095
 El proyecto SciPy <https://scipy.org> tiene muchos otros módulos para cálculos numéricos.
 Acceso a Internet
 Hay varios módulos para acceder a internet y procesar sus protocolos. Dos de los más simples son urllib.request para
 traer data de URLs y smtplib para mandar correos:
 >>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
 ...     for line in response:
 ...         line = line.decode('utf-8')  # Decoding the binary data to text.
 ...         if 'EST' in line or 'EDT' in line:  # look for Eastern Time
 ...             print(line)
 <BR>Nov. 25, 09:43:32 PM EST
 >>> import smtplib
 >>> server = smtplib.SMTP('localhost')
 >>> server.sendmail('soothsayer@ejemplo.org', 'jcaesar@ejemplo.org',
 ... """To: jcaesar@ejemplo.org
 ... From: soothsayer@ejemplo.org
 ...
 ... Ojo al piojo.
 ... """)
 >>> server.quit()
 (Notá que el segundo ejemplo necesita un servidor de correo corriendo en la máquina local)
 Fechas y tiempos
 El módulo datetime ofrece clases para manejar fechas y tiempos tanto de manera simple como compleja. Aunque soporta
 aritmética sobre fechas y tiempos, el foco de la implementación es en la extracción eficiente de partes para manejarlas o
 formatear la salida. El módulo también soporta objetos que son conscientes de la zona horaria.
 >>> # las fechas son fácilmente construidas y formateadas
 >>> from datetime import date
 >>> hoy = date.today()
 >>> hoy
 datetime.date(2009, 7, 19)
 >>> # nos aseguramos de tener la info de localización correcta
 >>> import locale
 >>> locale.setlocale(locale.LC_ALL, locale.getdefaultlocale())
 'es_ES.UTF8'
 >>> hoy.strftime("%m-%d-%y. %d %b %Y es %A. hoy es %d de %B.")
 '07-19-09. 19 jul 2009 es domingo. hoy es 19 de julio.'
 >>> # las fechas soportan aritmética de calendario
 >>> nacimiento = date(1964, 7, 31)
 >>> edad = hoy - nacimiento
 >>> edad.days
 14368
 74
Compresión de datos
 Los formatos para archivar y comprimir datos se soportan directamente con los módulos: zlib, gzip, bz2, lzma, zipfile
 y tarfile.
 >>> import zlib
 >>> s = b'witch which has which witches wrist watch'
 >>> len(s)
 41
 >>> t = zlib.compress(s)
 >>> len(t)
 37
 >>> zlib.decompress(t)
 b'witch which has which witches wrist watch'
 >>> zlib.crc32(s)
 226805979
 Medición de rendimiento
 Algunos usuarios de Python desarrollan un profundo interés en saber el rendimiento relativo de las diferentes soluciones al
 mismo problema. Python provee una herramienta de medición que responde esas preguntas inmediatamente.
 Por ejemplo, puede ser tentador usar la característica de empaquetamiento y desempaquetamiento de las tuplas en lugar de
 la solución tradicional para intercambiar argumentos. El módulo timeit muestra rapidamente una modesta ventaja de
 rendimiento:
 >>> from timeit import Timer
 >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
 0.57535828626024577
 >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
 0.54962537085770791
 En contraste con el fino nivel de granularidad del módulo timeit, los módulos profile y pstats proveen herramientas
 para identificar secciones críticas de tiempo en bloques de código más grandes.
 Control de calidad
 Una forma para desarrollar software de alta calidad es escribir pruebas para cada función mientras se la desarrolla, y correr
 esas pruebas frecuentemente durante el proceso de desarrollo.
 El módulo doctest provee una herramienta para revisar un módulo y validar las pruebas integradas en las cadenas de
 documentación (o docstring) del programa. La construcción de las pruebas es tan sencillo como cortar y pegar una ejecución
 típica junto con sus resultados en los docstrings. Esto mejora la documentación al proveer al usuario un ejemplo y permite
 que el módulo doctest se asegure que el código permanece fiel a la documentación:
 def promedio(valores):
    """Calcula la media aritmética de una lista de números.
    >>> print(promedio([20, 30, 70]))
    40.0
    """
    return sum(valores) / len(valores)
 import doctest
 doctest.testmod()   # valida automáticamente las pruebas integradas
 El módulo unittest necesita más esfuerzo que el módulo doctest, pero permite que se mantenga en un archivo
 separado un conjunto más comprensivo de pruebas:
 75
import unittest
 class TestFuncionesEstadisticas(unittest.TestCase):
 def test_promedio(self):
 self.assertEqual(promedio([20, 30, 70]), 40.0)
 self.assertEqual(round(promedio([1, 5, 7]), 1), 4.3)
 with self.assertRaises(ZeroDivisionError):
 promedio([])
 with self.assertRaises(TypeError):
 promedio(20, 30, 70)
 unittest.main()  # llamarlo de la linea de comandos ejecuta todas las pruebas
 Las pilas incluidas
 Python tiene una filosofía de "pilas incluidas". Esto se ve mejor en las capacidades robustas y sofisticadas de sus paquetes
 más grandes. Por ejemplo:
 •
 •
 •
 Los módulos xmlrpc.client y xmlrpc.server hacen que implementar llamadas a procedimientos remotos sea
 una tarea trivial. A pesar de los nombres de los módulos, no se necesita conocimiento directo o manejo de XML.
 El paquete email es una biblioteca para manejar mensajes de mail, incluyendo MIME y otros mensajes basados en
 RFC 2822. Al contrario de smtplib y poplib que en realidad envían y reciben mensajes, el paquete email tiene un
 conjunto de herramientas completo para construir y decodificar estructuras complejas de mensajes (incluyendo
 adjuntos) y para implementar protocolos de cabecera y codificación de Internet.
 El paquete json provee soporte robusto para parsear este popular formato de intercambio de datos. El módulo csv
 soporta una lectura y escritura directa de archivos de valores separados por coma, comunmente soportados por bases
 de datos y hojas de cálculos. Procesar XML es soportado por los paquetes xml.etree.ElementTree, xml.dom y
 xml.sax. Juntos, estos tres módulos y paquetes simplifican ampliamente el intercambio de datos entre aplicaciones
 Python y otras herramientas.
 •
 •
 El módulo sqlite3 es un wrapper para la librería de base de datos SQLite, proveyendo una base de datos persistente
 que puede ser actualizada y accedida utilizando sintaxis SQL ligeramente no estándar.
 Se soporta la internacionalización a través de varios módulos, incluyendo gettext, locale, y el paquete codecs.
 76
Pequeño paseo por la Biblioteca 
Estándar - Parte II
 Este segundo paseo cubre módulos más avanzados que facilitan necesidades de programación complejas. Estos módulos
 raramente se usan en scripts cortos.
 Formato de salida
 El módulo reprlib provee una versión de repr() ajustada para mostrar contenedores grandes o profundamente
 anidados, en forma abreviada:
 >>> import reprlib
 >>> reprlib.repr(set('supercalifragilisticoespialidoso'))
 "{'a', 'c', 'd', 'e', 'f', 'g', ...}"
 El módulo pprint ofrece un control más sofisticado de la forma en que se imprimen tanto los objetos predefinidos como los
 objetos definidos por el usuario, de manera que sean legibles por el intérprete. Cuando el resultado ocupa más de una línea,
 el generador de "impresiones lindas" agrega saltos de línea y sangrías para mostrar la estructura de los datos más
 claramente:
 >>> import pprint
 >>> t = [[[['negro', 'turquesa'], 'blanco', ['verde', 'rojo']], [['magenta',
 ...     'amarillo'], 'azul']]]
 ...
 >>> pprint.pprint(t, width=30)
 [[[['negro', 'turquesa'],
   'blanco',
   ['verde', 'rojo']],
  [['magenta', 'amarillo'],
   'azul']]]
 El módulo textwrap formatea párrafos de texto para que quepan dentro de cierto ancho de pantalla:
 >>> import textwrap
 >>> doc = """El método wrap() es como fill(), excepto que devuelve
 ... una lista de strings en lugar de una gran string con saltos de
 ... línea como separadores."""
 >>> print(textwrap.fill(doc, width=40))
 El método wrap() es como fill(), excepto
 que devuelve una lista de strings en
 lugar de una gran string con saltos de
 línea como separadores.
 El módulo locale accede a una base de datos de formatos específicos a una cultura. El atributo grouping de la función
 format() permite una forma directa de formatear números con separadores de grupo:
 >>> import locale
 >>> locale.setlocale(locale.LC_ALL, '')
 'Spanish_Argentina.1252'
 >>> conv = locale.localeconv()      # obtener un mapeo de convenciones
 >>> x = 1234567.8
 >>> locale.format("%d", x, grouping=True)
 '1.234.567'
 77
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
 ...                      conv['frac_digits'], x), grouping=True)
 '$1.234.567,80'
 Plantillas
 El módulo string incluye una clase versátil Template (plantilla) con una sintaxis simplificada apta para ser editada por
 usuarios finales. Esto permite que los usuarios personalicen sus aplicaciones sin necesidad de modificar la aplicación en sí.
 El formato usa marcadores cuyos nombres se forman con $ seguido de identificadores Python válidos (caracteres
 alfanuméricos y guión de subrayado). Si se los encierra entre llaves, pueden seguir más caracteres alfanuméricos sin
 necesidad de dejar espacios en blanco. $$ genera un $:
 >>> from string import Template
 >>> t = Template('${village}folk send $$10 to $cause.')
 >>> t.substitute(village='Nottingham', cause='the ditch fund')
 'Nottinghamfolk send $10 to the ditch fund.'
 El método substitute() lanza KeyError cuando no se suministra ningún valor para un marcador mediante un
 diccionario o argumento por nombre. Para algunas aplicaciones los datos suministrados por el usuario puede ser
 incompletos, y el método safe_substitute() puede ser más apropiado: deja los marcadores inalterados cuando hay
 datos faltantes:
 >>> t = Template('Return the $item to $owner.')
 >>> d = dict(item='unladen swallow')
 >>> t.substitute(d)
 Traceback (most recent call last):
  ...
 KeyError: 'owner'
 >>> t.safe_substitute(d)
 'Return the unladen swallow to $owner.'
 Las subclases de Template pueden especificar un delimitador propio. Por ejemplo, una utilidad de renombrado por lotes
 para un visualizador de fotos puede escoger usar signos de porcentaje para los marcadores tales como la fecha actual, el
 número de secuencia de la imagen, o el formato de archivo:
 >>> import time, os.path
 >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
 >>> class BatchRename(Template):
 ...     delimiter = '%'
 ...
 >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
 Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f
 >>> t = BatchRename(fmt)
 >>> date = time.strftime('%d%b%y')
 >>> for i, filename in enumerate(photofiles):
 ...     base, ext = os.path.splitext(filename)
 ...     newname = t.substitute(d=date, n=i, f=ext)
 ...     print('{0} --> {1}'.format(filename, newname))
 ...
 img_1074.jpg --> Ashley_0.jpg
 img_1076.jpg --> Ashley_1.jpg
 img_1077.jpg --> Ashley_2.jpg
 Las plantillas también pueden ser usadas para separar la lógica del programa de los detalles de múltiples formatos de
 salida. Esto permite sustituir plantillas específicas para archivos XML, reportes en texto plano, y reportes web en HTML.
 78
Trabajar con registros estructurados conteniendo datos binarios
 El módulo struct provee las funciones pack() y unpack() para trabajar con formatos de registros binarios de longitud
 variable. El siguiente ejemplo muestra cómo recorrer la información de encabezado en un archivo ZIP sin usar el módulo
 zipfile. Los códigos "H" e "I" representan números sin signo de dos y cuatro bytes respectivamente. El "<" indica que
 son de tamaño estándar y los bytes tienen ordenamiento little-endian:
 import struct
 with open('miarchivo.zip', 'rb') as f:
    datos = f.read()
 inicio = 0
 for i in range(3):                     # mostrar los 3 primeros encabezados
    inicio += 14
    campos = struct.unpack('<IIIHH', datos[inicio:inicio+16])
    crc32, tam_comp, tam_descomp, tam_nomarch, tam_extra = fields
    inicio += 16
    nomarch = datos[inicio:inicio+tam_nomarch]
    inicio += tam_nomarch
    extra = datos[inicio:inicio+tam_extra]
    print(nomarch, hex(crc32), tam_comp, tam_descomp)
    inicio += tam_extra + tam_comp     # saltear hasta el próximo encabezado
 Multi-hilos
 La técnica de multi-hilos (o multi-threading) permite desacoplar tareas que no tienen dependencia secuencial. Los hilos se
 pueden usar para mejorar el grado de reacción de las aplicaciones que aceptan entradas del usuario mientras otras tareas
 se ejecutan en segundo plano. Un caso de uso relacionado es ejecutar E/S en paralelo con cálculos en otro hilo.
 El código siguiente muestra cómo el módulo de alto nivel threading puede ejecutar tareas en segundo plano mientras el
 programa principal continúa su ejecución:
 import threading, zipfile
 class AsyncZip(threading.Thread):
    def __init__(self, arch_ent, arch_sal):
        threading.Thread.__init__(self)
        self.arch_ent = arch_ent
        self.arch_sal = arch_sal
    def run(self):
        f = zipfile.ZipFile(self.arch_sal, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.arch_ent)
        f.close()
        print('Terminó zip en segundo plano de: ', self.arch_ent)
 seg_plano = AsyncZip('misdatos.txt', 'miarchivo.zip')
 seg_plano.start()
 print('El programa principal continúa la ejecución en primer plano.')
 seg_plano.join()    # esperar que termine la tarea en segundo plano
 print('El programa principal esperó hasta que el segundo plano terminara.')
 El desafío principal de las aplicaciones multi-hilo es la coordinación entre los hilos que comparten datos u otros recursos. A
 ese fin, el módulo threading provee una serie de primitivas de sincronización que incluyen locks, eventos, variables de
 condición, y semáforos.
 79
Aún cuando esas herramientas son poderosas, pequeños errores de diseño pueden resultar en problemas difíciles de
 reproducir. La forma preferida de coordinar tareas es concentrar todos los accesos a un recurso en un único hilo y después
 usar el módulo queue para alimentar dicho hilo con pedidos desde otros hilos. Las aplicaciones que usan objetos Queue
 para comunicación y coordinación entre hilos son más fáciles de diseñar, más legibles, y más confiables.
 Registrando
 El módulo logging ofrece un sistema de registros (logs) completo y flexible. En su forma más simple, los mensajes de
 registro se envían a un archivo o a sys.stderr:
 import logging
 logging.debug('Información de depuración')
 logging.info('Mensaje informativo')
 logging.warning('Atención: archivo de configuración %s no se encuentra',
 'server.conf')
 logging.error('Ocurrió un error')
 logging.critical('Error crítico -- cerrando')
 Ésta es la salida obtenida:
 .. code-block:: none
 WARNING:root:Atención: archivo de configuración server.conf no se encuentra ERROR:root:Ocurrió un error
 CRITICAL:root:Error crítico -- cerrando
 De forma predeterminada, los mensajes de depuración e informativos se suprimen, y la salida se envía al error estándar.
 Otras opciones de salida incluyen mensajes de ruteo a través de correo electrónico, datagramas, sockets, o un servidor
 HTTP. Nuevos filtros pueden seleccionar diferentes rutas basadas en la prioridad del mensaje: DEBUG, INFO, WARNING,
 ERROR, and CRITICAL (Depuración, Informativo, Atención, Error y Crítico respectivamente)
 El sistema de registro puede configurarse directamente desde Python o puede cargarse la configuración desde un archivo
 editable por el usuario para personalizar el registro sin alterar la aplicación.
 Referencias débiles
 Python realiza administración de memoria automática (cuenta de referencias para la mayoría de los objetos, y garbage
 collection (recolección de basura) para eliminar ciclos). La memoria se libera poco después de que la última referencia a la
 misma haya sido eliminada.
 Esta estrategia funciona bien para la mayoría de las aplicaciones, pero ocasionalmente aparece la necesidad de hacer un
 seguimiento de objetos sólo mientras están siendo usados por alguien más. Desafortunadamente, el sólo hecho de
 seguirlos crea una referencia que los hace permanentes.
 El módulo weakref provee herramientas para seguimiento de objetos que no crean una referencia. Cuando el objeto no se
 necesita más, es eliminado automáticamente de una tabla de referencias débiles y se dispara una retrollamada (callback).
 Comúnmente se usa para mantener una cache de objetos que son caros de crear:
 >>> import weakref, gc
 >>> class A:
 ...     def __init__(self, valor):
 ...         self.valor = valor
 ...     def __repr__(self):
 ...         return str(self.valor)
 ...
 >>> a = A(10)                   # crear una referencia
 >>> d = weakref.WeakValueDictionary()
 >>> d['primaria'] = a            # no crea una referencia
 >>> d['primaria']                # traer el objeto si aún está vivo
 80
10
 >>> del a                       # eliminar la única referencia
 >>> gc.collect()                # recolección de basura justo ahora
 0
 >>> d['primaria']                # la entrada fue automáticamente eliminada
 Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    d['primaria']                # la entrada fue automáticamente eliminada
  File "C:/python36/lib/weakref.py", line 46, in __getitem__
    o = self.data[key]()
 KeyError: 'primaria'
 Herramientas para trabajar con listas
 Muchas necesidades de estructuras de datos pueden ser satisfechas con el tipo integrado lista. Sin embargo, a veces se
 hacen necesarias implementaciones alternativas con rendimientos distintos.
 El módulo array provee un objeto array() (vector) que es como una lista que almacena sólo datos homogéneos y de una
 manera más compacta. Los ejemplos a continuación muestran un vector de números guardados como dos números binarios
 sin signo de dos bytes (código de tipo "H") en lugar de los 16 bytes por elemento habituales en listas de objetos int de
 Python:
 >>> from array import array
 >>> a = array('H', [4000, 10, 700, 22222])
 >>> sum(a)
 26932
 >>> a[1:3]
 array('H', [10, 700])
 El módulo collections provee un objeto deque() que es como una lista más rápida para agregar y quitar elementos por
 el lado izquierdo pero con búsquedas más lentas por el medio. Estos objetos son adecuados para implementar colas y
 árboles de búsqueda a lo ancho:
 >>> from collections import deque
 >>> d = deque(["tarea1", "tarea2", "tarea3"])
 >>> d.append("tarea4")
 >>> print("Realizando", d.popleft())
 Realizando tarea1
 no_visitado = deque([nodo_inicial])
 def busqueda_a_lo_ancho(no_visitado):
    nodo = no_visitado.popleft()
    for m in gen_moves(nodo):
        if is_goal(m):
            return m
        no_visitado.append(m)
 Además de las implementaciones alternativas de listas, la biblioteca ofrece otras herramientas como el módulo bisect con
 funciones para manipular listas ordenadas:
 >>> import bisect
 >>> puntajes = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
 >>> bisect.insort(puntajes, (300, 'ruby'))
 >>> puntajes
 [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
 81
El módulo heapq provee funciones para implementar heaps basados en listas comunes. El menor valor ingresado se
 mantiene en la posición cero. Esto es útil para aplicaciones que acceden a menudo al elemento más chico pero no quieren
 hacer un orden completo de la lista:
 >>> from heapq import heapify, heappop, heappush
 >>> datos = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
 >>> heapify(datos)                     # acomodamos la lista a orden de heap
 >>> heappush(datos, -5)                # agregamos un elemento
 >>> [heappop(datos) for i in range(3)] # traemos los tres elementos menores
 [-5, 0, 1]
 Aritmética de punto flotante decimal
 El módulo decimal provee un tipo de dato Decimal para soportar aritmética de punto flotante decimal. Comparado con
 float, la implementación de punto flotante binario incluida, la clase es muy útil especialmente para:
 •aplicaciones financieras y para cualquier uso que requiera una representación decimal exacta,
 •control de la precisión,
 •control del redondeo para satisfacer requerimientos legales o reglamentarios,
 •seguimiento de cifras significativas,
 •o para aplicaciones donde el usuario espera que los resultados coincidan con cálculos hechos a mano.
 Por ejemplo, calcular un impuesto del 5% de una tarifa telefónica de 70 centavos da resultados distintos con punto flotante
 decimal y punto flotante binario. La diferencia se vuelve significativa si los resultados se redondean al centavo más próximo:
 >>> from decimal import *
 >>> round(Decimal('0.70') * Decimal('1.05'), 2)
 Decimal('0.74')
 >>> round(0.70 * 1.05, 2)
 0.73
 El resultado con Decimal conserva un cero al final, calculando automáticamente cuatro cifras significativas a partir de los
 multiplicandos con dos cifras significativas. Decimal reproduce la matemática como se la hace a mano, y evita problemas
 que pueden surgir cuando el punto flotante binario no puede representar exactamente cantidades decimales.
 La representación exacta permite a la clase Decimal hacer cálculos de modulo y pruebas de igualdad que son inadecuadas
 para punto flotante binario:
 >>> Decimal('1.00') % Decimal('.10')
 Decimal('0.00')
 >>> 1.00 % 0.10
 0.09999999999999995
 >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
 True
 >>> sum([0.1]*10) == 1.0
 False
 El módulo decimal provee aritmética con tanta precisión como haga falta:
 >>> getcontext().prec = 36
 >>> Decimal(1) / Decimal(7)
 Decimal('0.142857142857142857142857142857142857')
 82
Entornos Virtuales y Paquetes
 Introducción
 Las aplicaciones en Python usualmente hacen uso de paquetes y módulos que no forman parte de la librería estándar. Las
 aplicaciones a veces necesitan una versión específica de una librería, debido a que dicha aplicación requiere que un bug
 particular haya sido solucionado o bien la aplicación ha sido escrita usando una versión obsoleta de la interface de la
 librería.
 Esto significa que tal vez no sea posible para una instalación de Python cumplir los requerimientos de todas las
 aplicaciones. Si la aplicación A necesita la versión 1.0 de un módulo particular y la aplicación B necesita la versión 2.0,
 entonces los requerimientos entran en conflicto e instalar la versión 1.0 o 2.0 dejará una de las aplicaciones sin funcionar.
 La solución a este problema es crear un entorno virtual, un directorio que contiene una instalación de Python de una versión
 en particular, además de unos cuantos paquetes adicionales.
 Diferentes aplicaciones pueden entonces usar entornos virtuales diferentes. Para resolver el ejemplo de requerimientos en
 conflicto citado anteriormente, la aplicación A puede tener su propio entorno virtual con la versión 1.0 instalada mientras que
 la aplicación B tiene otro entorno virtual con la versión 2.0. Si la aplicación B requiere que actualizar la librería a la versión
 3.0, ésto no afectará el entorno virtual de la aplicación A.
 Creando Entornos Virtuales
 El script usado para crear y manejar entornos virtuales es pyvenv. pyvenv normalmente instalará la versión mas reciente de
 Python que tengas disponible; el script también es instalado con un número de versión, con lo que si tienes múltiples
 versiones de Python en tu sistema puedes seleccionar una versión de Python específica ejecutando python3 o la versión
 que desees.
 To create a virtual environment, decide upon a directory where you want to place it,
 Para crear un virtualenv, decide en que carpeta quieres crearlo y ejecuta el módulo venv como script con la ruta a la carpeta:
 python3 -m venv tutorial-env
 Esto creará la carpeta tutorial-env si no existe, y también creará las subcarpetas conteniendo la copia del intérprete
 Python, la librería estándar y los archivos de soporte.
 Una vez creado el entorno virtual, podrás activarlo.
 En Windows, ejecuta:
 tutorial-env\Scripts\activate.bat
 En Unix o MacOS, ejecuta:
 source tutorial-env/bin/activate
 (Este script está escrito para la consola bash. Si usas las consolas csh or fish, hay scripts alternativos activate.csh y
 activate.fish que deberá usar en su lugar).
 Activar el entorno virtual cambiará el prompt de tu consola para mostrar que entorno virtual está usando, y modificará el
 entorno para que al ejecutar python sea con esa versión e instalación en particular. Por ejemplo:
 83
$ source ~/envs/tutorial-env/bin/activate
 (tutorial-env) $ python
 Python 3.5.1 (default, May  6 2016, 10:59:36)
  ...
 >>> import sys
 >>> sys.path
 ['', '/usr/local/lib/python35.zip', ...,
 '~/envs/tutorial-env/lib/python3.5/site-packages']
 >>>
 Manejando paquetes con pip
 Es posible instalar, actualizar y quitar paquetes usando un programa llamado pip. Por defecto pip instalará paquetes desde
 Python Package Index (Indice de Paquetes Python), <https://pypi.python.org/pypi> . Se puede navegar el Python Package
 Index ingresando con su navegador de internet, o se puede usar la búsqueda limitada de pip's:
 (tutorial-env) $ pip search astronomy
 skyfield               - Elegant astronomy for Python
 gary                   - Galactic astronomy and gravitational dynamics.
 novas                  - The United States Naval Observatory NOVAS astronomy library
 astroobs               - Provides astronomy ephemeris to plan telescope observations
 PyAstronomy            - A collection of astronomy related tools for Python.
 ...
 pip tiene varios subcomandos: "search", "install", "uninstall", "freeze", etc. (consulta la guía Instalando módulos de Python
 para la documentación completa de pip.)
 Se puede instalar la última versión de un paquete especificando el nombre del paquete:
 (tutorial-env) $ pip install novas
 Collecting novas
  Downloading novas-3.1.1.3.tar.gz (136kB)
 Installing collected packages: novas
  Running setup.py install for novas
 Successfully installed novas-3.1.1.3
 También se puede instalar una verisón específica de un paquete ingresando el nombre del paquete seguido de == y el
 número de versión:
 (tutorial-env) $ pip install requests==2.6.0
 Collecting requests==2.6.0
  Using cached requests-2.6.0-py2.py3-none-any.whl
 Installing collected packages: requests
 Successfully installed requests-2.6.0
 Si se re-ejecuta el comando, pip detectará que la versión ya está instalada y no hará nada. Se puede ingresar un número de
 versión diferente para instalarlo, o se puede ejecutar pip install --upgrade para actualizar el paquete a la última
 versión:
 (tutorial-env) $ pip install --upgrade requests
 Collecting requests
 Installing collected packages: requests
  Found existing installation: requests 2.6.0
    Uninstalling requests-2.6.0:
      Successfully uninstalled requests-2.6.0
 Successfully installed requests-2.7.0
 pip uninstall seguido de uno o varios nombres de paquetes desinstalará los paquetes del entorno virtual.
 84
pip show mostrará información de un paquete en particular:
 (tutorial-env) $ pip show requests--
Metadata-Version: 2.0
 Name: requests
 Version: 2.7.0
 Summary: Python HTTP for Humans.
 Home-page: http://python-requests.org
 Author: Kenneth Reitz
 Author-email: me@kennethreitz.com
 License: Apache 2.0
 Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
 Requires:
 pip list mostrará todos los paquetes instalados en el entorno virtual:
 (tutorial-env) $ pip list
 novas (3.1.1.3)
 numpy (1.9.2)
 pip (7.0.3)
 requests (2.7.0)
 setuptools (16.0)
 pip freeze devuelve una lista de paquetes instalados similar, pero el formato de salida es el requerido por pip install.
 Una convención común es poner esta lista en un archivo requirements.txt:
 (tutorial-env) $ pip freeze > requirements.txt
 (tutorial-env) $ cat requirements.txt
 novas==3.1.1.3
 numpy==1.9.2
 requests==2.7.0
 El archivo requirements.txt entonces puede ser agregado a nuestro control de versiones y distribuído como parte de la
 aplicación. Los usuarios pueden entonces instalar todos los paquetes necesarios con install -r:
 (tutorial-env) $ pip install -r requirements.txt
 Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
  ...
 Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
  ...
 Collecting requests==2.7.0 (from -r requirements.txt (line 3))
  ...
 Installing collected packages: novas, numpy, requests
  Running setup.py install for novas
 Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0
 pip tiene muchas opciones más. Consulta la guía Instalando módulos de Python para la documentación de pip. Cuando
 hayas escrito un paquete y desees dejarlo disponible en Python Package Index, consulte la guía Glosario.
 85

¿Y ahora qué?
 Leer este tutorial probablemente reforzó tu interés por usar Python, deberías estar ansioso por aplicar Python a la resolución
 de tus problemas reales. ¿A dónde deberías ir para aprender más?
 Este tutorial forma parte del juego de documentación de Python. Algunos otros documentos que encontrarás en este juego
 son:
 • La referencia de la biblioteca:
 Deberías hojear este manual, que tiene material de referencia completo (si bien breve) sobre tipos, funciones y
 módulos de la biblioteca estándar. La distribución de Python estándar incluye un montón de código adicional. Hay
 módulos para leer archivos de correo de Unix, obtener documentos vía HTTP, generar números aleatorios, interpretar
 opciones de línea de comandos, escribir programas CGI, comprimir datos, y muchas otras tareas. Un vistazo por la
 Referencia de Biblioteca te dará una idea de lo que hay disponible.
 • Instalando módulos de Python explica cómo instalar módulos externos escritos por otros usuarios de Python.
 • La referencia del lenguaje: Una descripción en detalle de la sintaxis y semántica de Python. Es una lectura pesada,
 pero útil como guía completa al lenguaje en si.
 Más recursos sobre Python:
 • https://www.python.org: El sitio web principal sobre Python. Contiene código, documentación, y referencias a páginas
 relacionadas con Python en la Web. Este sitio web tiene copias espejo en varios lugares del mundo cómo Europa,
 Japón y Australia; una copia espejo puede funcionar más rápido que el sitio principal, dependiendo de tu ubicación
 geográfica.
 • https://docs.python.org: Acceso rápido a la documentación de Python.
 • https://pypi.python.org: El Índice de Paquetes de Python, antes también apodado "El Negocio de Quesos", es un
 listado de módulos de Python disponibles para descargar hechos por otros usuarios. Cuándo comiences a publicar
 código, puedes registrarlo aquí así los demás pueden encontrarlo.
 • https://code.activestate.com/recipes/langs/python/: El Recetario de Python es una colección de tamaño considerable
 de ejemplos de código, módulos más grandes, y programas útiles. Las contribuciones particularmente notorias están
 recolectadas en un libro también titulado Recetario de Python (O'Reilly & Associates, ISBN 0-596-00797-3.)
 • http://www.pyvideo.org recolecta links de videos relacionados con Python de conferencias y reuniones de grupos de
 usuarios.
 • https://scipy.org: El proyecto "Python Científico" incluye módulos para manipulación y cálculo rápido de arreglos
 además de incluir paquetes para cosas como álgebra lineal, transformaciones de Fourier, soluciones no lineales,
 distribuciones de números al azar, análisis estadísticos, y similares.
 Para preguntas relacionadas con Python y reportes de problemas puedes escribir al grupo de noticias comp.lang.python, o
 enviarlas a la lista de correo que hay en python-list@python.org. El grupo de noticias y la lista de correo están
 interconectadas, por lo que los mensajes enviados a uno serán retransmitidos al otro. Hay alrededor de cientos de mensajes
 diarios (con picos de hasta varios cientos), haciendo (y respondiendo) preguntas, sugiriendo nuevas características, y
 anunciando nuevos módulos. Antes de escribir, asegúrate de haber revisado la lista de Preguntas Frecuentes (también
 llamado el FAQ). Muchas veces responde las preguntas que se hacen una y otra vez, y quizáz contega la solución a tu
 problema.
 87
Hay archivos de la lista de correo disponibles en https://mail.python.org/pipermail/. El FAQ responde a muchas de las
 preguntas que aparecen una y otra vez, y puede que ya contenga la solución a tu problema.
 88
Edición de entrada interactiva y 
sustitución de historial
 Algunas versiones del intérprete de Python permiten editar la línea de entrada actual, y sustituir en base al historial, de forma
 similar a las capacidades del intérprete de comandos Korn y el GNU bash. Esto se implementa con la biblioteca GNU
 Readline, que soporta varios estilos de edición. Esta biblioteca tiene su propia documentación la cuál no vamos a duplicar
 aquí.
 Autocompletado con tab e historial de edición
 El autocompletado de variables y nombres de módulos es activado automáticamente al iniciar el intérprete, por lo tanto
 la tecla Tab invoca la función de autocompletado; ésta mira en los nombres de sentencia, las variables locales y los nombres
 de módulos disponibles. Para expresiones con puntos como string.a, va a evaluar la expresión hasta el '.' final y
 entonces sugerir autocompletado para los atributos del objeto resultante. Nota que esto quizás ejecute código de
 aplicaciones definidas si un objeto con un método __getattr__() es parte de la expresión. La configuración por omisión
 también guarda tu historial en un archivo llamado .python_history en tu directorio de usuario. El historial estará disponible
 durante la próxima sesión interactiva del intérprete.
 Alternativas al intérprete interactivo
 Esta funcionalidad es un paso enorme hacia adelante comparado con versiones anteriores del interprete; de todos modos,
 quedan pendientes algunos deseos: sería bueno que el sangrado correcto se sugiriera en las lineas de continuación (el
 parser sabe si se requiere un sangrado a continuación). El mecanismo de completado podría usar la tabla de símbolos del
 intérprete. Un comando para verificar (o incluso sugerir) coincidencia de paréntesis, comillas, etc. también sería útil.
 Un intérprete interactivo mejorado alternativo que está dando vueltas desde hace rato es IPython, que ofrece completado por
 tab, exploración de objetos, y administración avanzada del historial. También puede ser configurado en profundidad, e
 integrarse en otras aplicaciones. Otro entorno interactivo mejorado similar es bpython.
 89

Aritmética de Punto Flotante: 
Problemas y Limitaciones
 Los números de punto flotante se representan en el hardware de la computadora en fracciones en base 2 (binario). Por
 ejemplo, la fracción decimal
 0.125
 ...tiene el valor 1/10 + 2/100 + 5/1000, y de la misma manera la fracción binaria
 0.001
 ...tiene el valor 0/2 + 0/4 + 1/8. Estas dos fracciones tienen valores idénticos, la única diferencia real es que la primera está
 escrita en notación fraccional en base 10 y la segunda en base 2.
 Desafortunadamente, la mayoría de las fracciones decimales no pueden representarse exactamente como fracciones
 binarias. Como consecuencia, en general los números de punto flotante decimal que ingresás en la computadora son sólo
 aproximados por los números de punto flotante binario que realmente se guardan en la máquina.
 El problema es más fácil de entender primero en base 10. Considerá la fracción 1/3. Podés aproximarla como una fracción
 de base 10
 0.3
 ...o, mejor,
 0.33
 ...o, mejor,
 0.333
 ...y así. No importa cuantos dígitos desees escribir, el resultado nunca será exactamente 1/3, pero será una aproximación
 cada vez mejor de 1/3.
 De la misma manera, no importa cuantos dígitos en base 2 quieras usar, el valor decimal 0.1 no puede representarse
 exactamente como una fracción en base 2. En base 2, 1/10 es la siguiente fracción que se repite infinitamente:
 0.0001100110011001100110011001100110011001100110011...
 Frená en cualquier número finito de bits, y tendrás una aproximación. En la mayoría de las máquinas hoy en día, los float se
 aproximan usando una fracción binaria con el numerador usando los primeros 53 bits con el bit más significativos y el
 denominador como una potencia de dos. En el caso de 1/10, la fracción binaria es 3602879701896397 / 2 ** 55 que
 está cerca pero no es exactamente el valor verdadero de 1/10.
 La mayoría de los usuarios no son conscientes de esta aproximación por la forma en que se muestran los valores. Python
 solamente muestra una aproximación decimal al valor verdadero decimal de la aproximación binaria almacenada por la
 máquina. En la mayoría de las máquinas, si Python fuera a imprimir el verdadero valor decimal de la aproximación binaria
 almacenada para 0.1, debería mostrar
 >>> 0.1
 0.1000000000000000055511151231257827021181583404541015625
 Esos son más dígitos que lo que la mayoría de la gente encuentra útil, por lo que Python mantiene manejable la cantidad de
 dígitos al mostrar en su lugar un valor redondeado
 91
>>> 1 / 10
 0.1
 Sólo recordá que, a pesar de que el valor mostrado resulta ser exactamente 1/10, el valor almacenado realmente es la
 fracción binaria más cercana posible.
 Interesantemente, hay varios números decimales que comparten la misma fracción binaria más aproximada. Por ejemplo, los
 números 0.1, 0.10000000000000001 y 0.1000000000000000055511151231257827021181583404541015625 son
 todos aproximados por 3602879701896397 / 2 ** 55. Ya que todos estos valores decimales comparten la misma
 aproximación, se podría mostrar cualquiera de ellos para preservar el invariante eval(repr(x)) == x.
 Históricamente, el prompt de Python y la función integrada repr() eligieron el valor con los 17 dígitos,
 0.10000000000000001. Desde Python 3.1, en la mayoría de los sistemas Python ahora es capaz de elegir la forma más
 corta de ellos y mostrar 0.1.
 Notá que esta es la verdadera naturaleza del punto flotante binario: no es un error de Python, y tampoco es un error en tu
 código. Verás lo mismo en todos los lenguajes que soportan la aritmética de punto flotante de tu hardware (a pesar de que
 en algunos lenguajes por omisión no muestren la diferencia, o no lo hagan en todos los modos de salida).
 Para una salida más elegante, quizás quieras usar el formateo de cadenas de texto para generar un número limitado de
 dígitos significativos:
 >>> format(math.pi, '.12g')  # da 12 dígitos significativos
 '3.14159265359'
 >>> format(math.pi, '.2f')   # da 2 dígitos luego del punto
 '3.14'
 >>> repr(math.pi)
 '3.141592653589793'
 Es importante darse cuenta que esto es, realmente, una ilusión: estás simplemente redondeando al mostrar el valor
 verdadero de la máquina.
 Una ilusión puede generar otra. Por ejemplo, ya que 0.1 no es exactamente 1/10, sumar tres veces 0.1 podría también no
 generar exactamente 0.3:
 >>> .1 + .1 + .1 == .3
 False
 También, ya que 0.1 no puede acercarse más al valor exacto de 1/10 y 0.3 no puede acercarse más al valor exacto de 3/10,
 redondear primero con la función round() no puede ayudar:
 >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
 False
 A pesar que los números no pueden acercarse a los valores exactos que pretendemos, la función round() puede ser útil
 para redondear a posteriori, para que los resultados con valores inexactos se puedan comparar entre sí:
 >>> round(.1 + .1 + .1, 10) == round(.3, 10)
 True
 La aritmética de punto flotante binaria tiene varias sorpresas como esta. El problema con "0.1" es explicado con detalle
 abajo, en la sección "Error de Representación". Mirá los Peligros del Punto Flotante (en inglés, The Perils of Floating Point)
 para una más completa recopilación de otras sorpresas normales.
 Como dice cerca del final, "no hay respuestas fáciles". A pesar de eso, ¡no le tengas mucho miedo al punto flotante! Los
 errores en las operaciones flotantes de Python se heredan del hardware de punto flotante, y en la mayoría de las máquinas
 están en el orden de no más de una 1 parte en 2**53 por operación. Eso es más que adecuado para la mayoría de las
 92
tareas, pero necesitás tener en cuenta que no es aritmética decimal, y que cada operación de punto flotante sufre un nuevo
 error de redondeo.
 A pesar de que existen casos patológicos, para la mayoría de usos casuales de la aritmética de punto flotante al final verás
 el resultado que esperás si simplemente redondeás lo que mostrás de tus resultados finales al número de dígitos decimales
 que esperás. str() es normalmente suficiente, y para un control más fino mirá los parámetros del método de formateo
 str.format() en Tipos integrados.
 Para los casos de uso que necesitan una representación decimal exacta, probá el módulo decimal, que implementa
 aritmética decimal útil para aplicaciones de contabilidad y de alta precisión.
 El módulo fractions soporta otra forma de aritmética exacta, ya que implementa aritmética basada en números racionales
 (por lo que números como 1/3 pueden ser representados exactamente).
 Si sos un usuario frecuente de las operaciones de punto flotante deberías pegarle una mirada al paquete Numerical Python y
 otros paquetes para operaciones matemáticas y estadísticas provistos por el proyecto SciPy. Mirá <https://scipy.org>.
 Python provee herramientas que pueden ayudar en esas raras ocasiones cuando realmente querés saber el valor exacto de
 un float. El método float.as_integer_ratio() expresa el valor del float como una fracción:
 >>> x = 3.14159
 >>> x.as_integer_ratio()
 (3537115888337719, 1125899906842624)
 Ya que la fracción es exacta, se puede usar para recrear sin pérdidas el valor original:
 >>> x == 3537115888337719 / 1125899906842624
 True
 El método float.hex() expresa un float en hexadecimal (base 16), nuevamente devolviendo el valor exacto almacenado
 por tu computadora:
 >>> x.hex()
 '0x1.921f9f01b866ep+1'
 Esta representación hexadecimal precisa se puede usar para reconstruir el valor exacto del float:
 >>> x == float.fromhex('0x1.921f9f01b866ep+1')
 True
 Ya que la representación es exacta, es útil para portar valores a través de diferentes versiones de Python de manera
 confiable (independencia de plataformas) e intercambiar datos con otros lenguajes que soportan el mismo formato (como
 Java y C99).
 Otra herramienta útil es la función math.fsum() que ayuda a mitigar la pérdida de precisión durante la suma. Esta función
 lleva la cuenta de "dígitos perdidos" mientras se suman los valores en un total. Eso puede hacer una diferencia en la
 exactitud de lo que se va sumando para que los errores no se acumulen al punto en que afecten el total final:
 >>> sum([0.1] * 10) == 1.0
 False
 >>> math.fsum([0.1] * 10) == 1.0
 True
 Error de Representación
 Esta sección explica el ejemplo "0.1" en detalle, y muestra como en la mayoría de los casos vos mismo podés realizar un
 análisis exacto como este. Se asume un conocimiento básico de la representación de punto flotante binario.
 93
Error de representación se refiere al hecho de que algunas (la mayoría) de las fracciones decimales no pueden
 representarse exactamente como fracciones binarias (en base 2). Esta es la razón principal de por qué Python (o Perl, C,
 C++, Java, Fortran, y tantos otros) frecuentemente no mostrarán el número decimal exacto que esperás.
 ¿Por qué es eso? 1/10 no es representable exactamente como una fracción binaria. Casi todas las máquinas de hoy en día
 (Noviembre del 2000) usan aritmética de punto flotante IEEE-754, y casi todas las plataformas mapean los flotantes de
 Python al "doble precisión" de IEEE-754. Estos "dobles" tienen 53 bits de precisión, por lo tanto en la entrada la computadora
 intenta convertir 0.1 a la fracción más cercana que puede de la forma J/2***N* donde J es un entero que contiene
 exactamente 53 bits. Reescribiendo
 1 / 10 ~= J / (2**N)
 ...como
 J ~= 2**N / 10
 ...y recordando que J tiene exactamente 53 bits (es >= 2**52 pero < 2**53), el mejor valor para N es 56:
 >>> 2**52 <=  2**56 // 10  < 2**53
 True
 O sea, 56 es el único valor para N que deja J con exactamente 53 bits. El mejor valor posible para J es entonces el cociente
 redondeado:
 >>> q, r = divmod(2**56, 10)
 >>> r
 6
 Ya que el resto es más que la mitad de 10, la mejor aproximación se obtiene redondeándolo:
 >>> q+1
 7205759403792794
 Por lo tanto la mejor aproximación a 1/10 en doble precisión 754 es:
 7205759403792794 / 2 ** 56
 El dividir tanto el numerador como el denominador reduce la fracción a:
 3602879701896397 / 2 ** 55
 Notá que como lo redondeamos, esto es un poquito más grande que 1/10; si no lo hubiéramos redondeado, el cociente
 hubiese sido un poquito menor que 1/10. ¡Pero no hay caso en que sea exactamente 1/10!
 Entonces la computadora nunca "ve" 1/10: lo que ve es la fracción exacta de arriba, la mejor aproximación al flotante doble
 de 754 que puede obtener:
 >>> 0.1 * 2 ** 55
 3602879701896397.0
 Si multiplicamos esa fracción por 10**55, podemos ver el valor hasta los 55 dígitos decimales:
 >>> 3602879701896397 * 10 ** 55 // 2 ** 55
 1000000000000000055511151231257827021181583404541015625
 ...lo que significa que el valor exacto almacenado en la computadora es igual al valor decimal
 0.1000000000000000055511151231257827021181583404541015625. En lugar de mostrar el valor decimal completo,
 muchos lenguajes (incluyendo versiones más viejas de Python), redondean el resultado a 17 dígitos significativos:
 >>> format(0.1, '.17f')
 '0.10000000000000001'
 94
Los módulos fractions y decimal hacen fácil estos cálculos:
 >>> from decimal import Decimal
 >>> from fractions import Fraction
 >>> Fraction.from_float(0.1)
 Fraction(3602879701896397, 36028797018963968)
 >>> (0.1).as_integer_ratio()
 (3602879701896397, 36028797018963968)
 >>> Decimal.from_float(0.1)
 Decimal('0.1000000000000000055511151231257827021181583404541015625')
 >>> format(Decimal.from_float(0.1), '.17')
 '0.10000000000000001'
 95

Links a la documentación de Python
 Lo siguiente es una serie de enlaces que apuntan a la documentación de Python que no está traducida.
 Se incluye aquí sólo a modo de referencia, y para hacer poder llegar fácil a la documentación de cada ítem cuando se
 apunta al mismo en el tutorial.
 Extendiendo e Integrando el Intérprete de Python
 • Índice
 Referencia de la API Python/C
 • Índice
 La referencia de la biblioteca
 • Índice
 Tipos integrados
 • Tipos de cadena
 • Métodos de las cadenas
 • Formateo de cadenas
 • Antiguo formateo de cadenas
 • Tipos de mapeo
 • Tipos de secuencia
 • Tipos de números complejos
 Excepciones integradas
 • Excepciones integradas
 La referencia del lenguaje
 • Índice
 Expresiones
 • lambda
 • in
 97
Declaraciones simples
 • assert
 • break
 • continue
 • del
 • global
 • import
 • nonlocal
 • pass
 • raise
 • return
 • yield
 Declaraciones compuestas
 • for
 • if, elif, else
 • try, except, finally
 • while
 • with
 • def
 Instalando módulos de Python
 • Índice
 Glosario
 mutables
 https://docs.python.org/3/glossary.html#term-mutable
 archivo de texto
 https://docs.python.org/3/glossary.html#term-text-file
 entorno virtual
 https://docs.python.org/3/glossary.html#term-virtual-environment
 Distribuyendo módulos de Python
 • Índice
 98
 Línea de comandos y entorno
• Línea de comandos y entorno
 99

Apéndice
 Modo interactivo
 Manejo de errores
 Cuando ocurre un error, el intérprete imprime un mensaje de error y la traza del error. En el modo interactivo, luego retorna al
 prompt primario; cuando la entrada viene de un archivo, el programa termina con código de salida distinto a cero luego de
 imprimir la traza del error. (Las excepciones manejadas por una clausula except en una sentencia try no son errores en
 este contexto). Algunos errores son incondicionalmente fatales y causan una terminación con código de salida distinto de
 cero; esto se debe a inconsistencias internas o a que el intérprete se queda sin memoria. Todos los mensajes de error se
 escriben en el flujo de errores estándar; las salidas normales de comandos ejecutados se escriben en la salida estándar.
 Al ingresar el caracter de interrupción (por lo general Control-C o Supr) en el prompt primario o secundario, se cancela la
 entrada y retorna al prompt primario. 9 Tipear una interrupción mientras un comando se están ejecutando lanza la excepción
 KeyboardInterrupt, que puede ser manejada con una sentencia try.
 Programas ejecutables de Python
 En los sistemas Unix y tipo BSD, los programas Python pueden convertirse directamente en ejecutables, como programas
 del intérprete de comandos, poniendo la linea:
 #! /usr/bin/env python3.5
 ...al principio del script y dándole al archivo permisos de ejecución (asumiendo que el intérprete están en la variable de
 entorno PATH del usuario). #! deben ser los primeros dos caracteres del archivo. En algunas plataformas, la primera línea
 debe terminar al estilo Unix ('\n'), no como en Windows ('\r\n'). Notá que el caracter numeral '#' se usa en Python
 para comenzar un comentario.
 Se le puede dar permisos de ejecución al script usando el comando chmod:
 .. code-block:: bash
 $ chmod +x myscript.py
 En sistemas Windows, no existe la noción de "modo ejecutable". El instalador de Python asocia automáticamente la
 extensión .py con python.exe para que al hacerle doble click a un archivo Python se corra el script. La extensión también
 puede ser .pyw, en este caso se omite la ventana con la consola que normalmente aparece.
 El archivo de inicio interactivo
 Cuando usás Python en forma interactiva, suele ser útil que algunos comandos estándar se ejecuten cada vez que el
 intérprete se inicia. Podés hacer esto configurando la variable de entorno PYTHONSTARTUP con el nombre de un archivo que
 contenga tus comandos de inicio. Esto es similar al archivo .profile en los intérpretes de comandos de Unix.
 Este archivo es solo leído en las sesiones interactivas del intérprete, no cuando Python lee comandos de un script ni cuando
 /dev/tty se explicita como una fuente de comandos (que de otro modo se comporta como una sesión interactiva). Se ejecuta
 en el mismo espacio de nombres en el que los comandos interactivos se ejecutan, entonces los objetos que define o importa
 pueden ser usados sin cualificaciones en la sesión interactiva. En este archivo también podés cambiar los prompts sys.ps1
 y sys.ps2.
 101
Si querés leer un archivo de inicio adicional desde el directorio actual, podés programarlo en el archivo de inicio global
 usando algo como if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read()). Si querés
 usar el archivo de inicio en un script, tenés que hacer lo siguiente de forma explícita en el script:
 import os
 nombrearchivo = os.environ.get('PYTHONSTARTUP')
 if nombrearchivo and os.path.isfile(nombrearchivo):
 with open(nombrearchivo) as fobj:
 archivo_inicio = fobj.read()
 exec(archivo_inicio)
 Los módulos de customización
 Python provee dos formas para customizarlo: sitecustomize y usercustomize. Para ver como funciona, necesitás
 primero encontrar dónde está tu directorio para tu usuario de paquetes del sistema. Arrancá Python y ejecutá el siguiente
 código:
 >>> import site
 >>> site.getusersitepackages()
 '/home/user/.local/lib/python3.5/site-packages'
 Ahora podés crear un archivo llamado usercustomize.py en ese directorio y poner lo que quieras en él. Eso afectará cada
 ejecución de Python, a menos que se arranque con la opción -s para deshabilitar esta importación automática.
 sitecustomize funciona de la misma manera, pero normalmente lo crea el administrador de la computadora en el
 directorio global de paquetes para el sistema, y se importa antes que usercustomize. Para más detalles, mirá la
 documentación del módulo site.
 9
 A problem with the GNU Readline package may prevent this.
 102
103